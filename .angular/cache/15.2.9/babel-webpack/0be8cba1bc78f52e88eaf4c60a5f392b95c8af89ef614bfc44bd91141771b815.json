{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MeetingImpl = exports.Meeting = void 0;\n/* eslint-disable max-classes-per-file */\nconst Exports_js_1 = require(\"../../common.speech/Exports.js\");\nconst Exports_js_2 = require(\"../../common/Exports.js\");\nconst Contracts_js_1 = require(\"../Contracts.js\");\nconst Exports_js_3 = require(\"../Exports.js\");\nclass Meeting {\n  constructor() {\n    return;\n  }\n  /**\n   * Create a meeting\n   * @param speechConfig\n   * @param meetingId\n   * @param cb\n   * @param err\n   */\n  static createMeetingAsync(speechConfig, meetingId, arg3, arg4) {\n    Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig, Exports_js_1.ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"config\"));\n    Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig.region, Exports_js_1.ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Region\"));\n    Contracts_js_1.Contracts.throwIfNull(meetingId, \"meetingId\");\n    if (meetingId.length === 0) {\n      throw new Error(\"meetingId cannot be empty\");\n    }\n    if (!speechConfig.subscriptionKey && !speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceAuthorization_Token])) {\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, Exports_js_1.ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Key\"));\n    }\n    const meetingImpl = new MeetingImpl(speechConfig, meetingId);\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    Exports_js_2.marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {}))(), arg3, arg4);\n    return meetingImpl;\n  }\n}\nexports.Meeting = Meeting;\nclass MeetingImpl extends Meeting {\n  /**\n   * Create a Meeting impl\n   * @param speechConfig\n   * @param {string} id - optional conversationId\n   */\n  constructor(speechConfig, id) {\n    super();\n    this.privErrors = Exports_js_1.ConversationConnectionConfig.restErrors;\n    /** websocket callbacks */\n    /* eslint-disable @typescript-eslint/typedef */\n    this.onConnected = e => {\n      var _a;\n      this.privIsConnected = true;\n      try {\n        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.sessionStarted)) {\n          this.privConversationTranslator.sessionStarted(this.privConversationTranslator, e);\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onDisconnected = e => {\n      var _a;\n      try {\n        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.sessionStopped)) {\n          this.privConversationTranslator.sessionStopped(this.privConversationTranslator, e);\n        }\n      } catch (e) {\n        //\n      } finally {\n        void this.close(false);\n      }\n    };\n    this.onCanceled = (r, e) => {\n      var _a;\n      try {\n        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.canceled)) {\n          this.privConversationTranslator.canceled(this.privConversationTranslator, e);\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onParticipantUpdateCommandReceived = (r, e) => {\n      try {\n        const updatedParticipant = this.privParticipants.getParticipant(e.id);\n        if (updatedParticipant !== undefined) {\n          switch (e.key) {\n            case Exports_js_1.ConversationTranslatorCommandTypes.changeNickname:\n              updatedParticipant.displayName = e.value;\n              break;\n            case Exports_js_1.ConversationTranslatorCommandTypes.setUseTTS:\n              updatedParticipant.isUsingTts = e.value;\n              break;\n            case Exports_js_1.ConversationTranslatorCommandTypes.setProfanityFiltering:\n              updatedParticipant.profanity = e.value;\n              break;\n            case Exports_js_1.ConversationTranslatorCommandTypes.setMute:\n              updatedParticipant.isMuted = e.value;\n              break;\n            case Exports_js_1.ConversationTranslatorCommandTypes.setTranslateToLanguages:\n              updatedParticipant.translateToLanguages = e.value;\n              break;\n          }\n          this.privParticipants.addOrUpdateParticipant(updatedParticipant);\n          if (!!this.privConversationTranslator) {\n            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.Updated, [this.toParticipant(updatedParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onLockRoomCommandReceived = () => {\n      // TODO\n    };\n    this.onMuteAllCommandReceived = (r, e) => {\n      try {\n        this.privParticipants.participants.forEach(p => p.isMuted = p.isHost ? false : e.isMuted);\n        if (!!this.privConversationTranslator) {\n          this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.Updated, this.toParticipants(false), e.sessionId));\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onParticipantJoinCommandReceived = (r, e) => {\n      try {\n        const newParticipant = this.privParticipants.addOrUpdateParticipant(e.participant);\n        if (newParticipant !== undefined) {\n          if (!!this.privConversationTranslator) {\n            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.JoinedConversation, [this.toParticipant(newParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onParticipantLeaveCommandReceived = (r, e) => {\n      try {\n        const ejectedParticipant = this.privParticipants.getParticipant(e.participant.id);\n        if (ejectedParticipant !== undefined) {\n          // remove the participant from the internal participants list\n          this.privParticipants.deleteParticipant(e.participant.id);\n          if (!!this.privConversationTranslator) {\n            // notify subscribers that the participant has left the conversation\n            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.LeftConversation, [this.toParticipant(ejectedParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onTranslationReceived = (r, e) => {\n      try {\n        switch (e.command) {\n          case Exports_js_1.ConversationTranslatorMessageTypes.final:\n            if (!!this.privConversationTranslator) {\n              this.privConversationTranslator.transcribed(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n            break;\n          case Exports_js_1.ConversationTranslatorMessageTypes.partial:\n            if (!!this.privConversationTranslator) {\n              this.privConversationTranslator.transcribing(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n            break;\n          case Exports_js_1.ConversationTranslatorMessageTypes.instantMessage:\n            if (!!this.privConversationTranslator) {\n              this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n            break;\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onParticipantsListReceived = (r, e) => {\n      var _a;\n      try {\n        // check if the session token needs to be updated\n        if (e.sessionToken !== undefined && e.sessionToken !== null) {\n          this.privRoom.token = e.sessionToken;\n        }\n        // save the participants\n        this.privParticipants.participants = [...e.participants];\n        // enable the conversation\n        if (this.privParticipants.me !== undefined) {\n          this.privIsReady = true;\n        }\n        if (!!this.privConversationTranslator) {\n          this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.JoinedConversation, this.toParticipants(true), e.sessionId));\n        }\n        // if this is the host, update the nickname if needed\n        if (this.me.isHost) {\n          const nickname = (_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.properties.getProperty(Exports_js_3.PropertyId.ConversationTranslator_Name);\n          if (nickname !== undefined && nickname.length > 0 && nickname !== this.me.displayName) {\n            // issue a change nickname request\n            this.changeNicknameAsync(nickname);\n          }\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onConversationExpiration = (r, e) => {\n      try {\n        if (!!this.privConversationTranslator) {\n          this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, e);\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.privIsConnected = false;\n    this.privIsDisposed = false;\n    this.privConversationId = \"\";\n    this.privProperties = new Exports_js_3.PropertyCollection();\n    this.privManager = new Exports_js_1.ConversationManager();\n    // check the speech language\n    const language = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);\n    if (!language) {\n      speechConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage], Exports_js_1.ConversationConnectionConfig.defaultLanguageCode);\n    }\n    this.privLanguage = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);\n    this.privConversationId = id;\n    // save the speech config for future usage\n    this.privConfig = speechConfig;\n    // save the config properties\n    const configImpl = speechConfig;\n    Contracts_js_1.Contracts.throwIfNull(configImpl, \"speechConfig\");\n    this.privProperties = configImpl.properties.clone();\n    this.privIsConnected = false;\n    this.privParticipants = new Exports_js_1.InternalParticipants();\n    this.privIsReady = false;\n    this.privTextMessageMaxLength = 1000;\n  }\n  // get the internal data about a conversation\n  get room() {\n    return this.privRoom;\n  }\n  // get the wrapper for connecting to the websockets\n  get connection() {\n    return this.privConversationRecognizer; // this.privConnection;\n  }\n  // get the config\n  get config() {\n    return this.privConfig;\n  }\n  // get the meeting Id\n  get meetingId() {\n    return this.privRoom ? this.privRoom.roomId : this.privConversationId;\n  }\n  // get the properties\n  get properties() {\n    return this.privProperties;\n  }\n  // get the speech language\n  get speechRecognitionLanguage() {\n    return this.privLanguage;\n  }\n  get isMutedByHost() {\n    var _a, _b;\n    return ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost) ? false : (_b = this.privParticipants.me) === null || _b === void 0 ? void 0 : _b.isMuted;\n  }\n  get isConnected() {\n    return this.privIsConnected && this.privIsReady;\n  }\n  get participants() {\n    return this.toParticipants(true);\n  }\n  get me() {\n    return this.toParticipant(this.privParticipants.me);\n  }\n  get host() {\n    return this.toParticipant(this.privParticipants.host);\n  }\n  get transcriberRecognizer() {\n    return this.privTranscriberRecognizer;\n  }\n  get meetingInfo() {\n    const convId = this.meetingId;\n    const p = this.participants.map(part => ({\n      id: part.id,\n      preferredLanguage: part.preferredLanguage,\n      voice: part.voice\n    }));\n    const props = {};\n    for (const key of Exports_js_1.ConversationConnectionConfig.transcriptionEventKeys) {\n      const val = this.properties.getProperty(key, \"\");\n      if (val !== \"\") {\n        props[key] = val;\n      }\n    }\n    const info = {\n      id: convId,\n      participants: p,\n      meetingProperties: props\n    };\n    return info;\n  }\n  get canSend() {\n    var _a;\n    return this.privIsConnected && !((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isMuted);\n  }\n  get canSendAsHost() {\n    var _a;\n    return this.privIsConnected && ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost);\n  }\n  // get / set the speech auth token\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  get authorizationToken() {\n    return this.privToken;\n  }\n  set authorizationToken(value) {\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(value, \"authorizationToken\");\n    this.privToken = value;\n  }\n  /**\n   * Create a new meeting as Host\n   * @param cb\n   * @param err\n   */\n  createMeetingAsync(cb, err) {\n    try {\n      if (!!this.privConversationRecognizer) {\n        this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\n      }\n      this.privManager.createOrJoin(this.privProperties, undefined, room => {\n        if (!room) {\n          this.handleError(new Error(this.privErrors.permissionDeniedConnect), err);\n        }\n        this.privRoom = room;\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Starts a new meeting as host.\n   * @param cb\n   * @param err\n   */\n  startMeetingAsync(cb, err) {\n    try {\n      // check if there is already a recognizer\n      if (!!this.privConversationRecognizer) {\n        this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\n      }\n      // check if there is conversation data available\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);\n      // connect to the conversation websocket\n      this.privParticipants.meId = this.privRoom.participantId;\n      // Because ConversationTranslator manually sets up and manages the connection, Conversation\n      // has to forward serviceRecognizer connection events that usually get passed automatically\n      this.privConversationRecognizer.connected = this.onConnected;\n      this.privConversationRecognizer.disconnected = this.onDisconnected;\n      this.privConversationRecognizer.canceled = this.onCanceled;\n      this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;\n      this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;\n      this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;\n      this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;\n      this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;\n      this.privConversationRecognizer.translationReceived = this.onTranslationReceived;\n      this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;\n      this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;\n      this.privConversationRecognizer.connect(this.privRoom.token, () => {\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Join a meeting as a participant.\n   * @param { IParticipant } participant - participant to add\n   * @param cb\n   * @param err\n   */\n  addParticipantAsync(participant, cb, err) {\n    Contracts_js_1.Contracts.throwIfNullOrUndefined(participant, \"Participant\");\n    Exports_js_2.marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb, err);\n  }\n  /**\n   * Join a meeting as a participant.\n   * @param meeting\n   * @param nickname\n   * @param lang\n   * @param cb\n   * @param err\n   */\n  joinMeetingAsync(meetingId, nickname, lang, cb, err) {\n    try {\n      // TODO\n      // if (!!this.privConversationRecognizer) {\n      //     throw new Error(this.privErrors.permissionDeniedStart);\n      // }\n      Contracts_js_1.Contracts.throwIfNullOrWhitespace(meetingId, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversationId\"));\n      Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n      Contracts_js_1.Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace(\"{arg}\", \"language\"));\n      // join the conversation\n      this.privManager.createOrJoin(this.privProperties, meetingId, room => {\n        Contracts_js_1.Contracts.throwIfNullOrUndefined(room, this.privErrors.permissionDeniedConnect);\n        this.privRoom = room;\n        this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;\n        // join callback\n        if (!!cb) {\n          cb(room.cognitiveSpeechAuthToken);\n        }\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Deletes a meeting\n   * @param cb\n   * @param err\n   */\n  deleteMeetingAsync(cb, err) {\n    Exports_js_2.marshalPromiseToCallbacks(this.deleteMeetingImplAsync(), cb, err);\n  }\n  deleteMeetingImplAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);\n      Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);\n      yield this.privManager.leave(this.privProperties, this.privRoom.token);\n      this.dispose();\n    });\n  }\n  /**\n   * Issues a request to close the client websockets\n   * @param cb\n   * @param err\n   */\n  endMeetingAsync(cb, err) {\n    Exports_js_2.marshalPromiseToCallbacks(this.endMeetingImplAsync(), cb, err);\n  }\n  endMeetingImplAsync() {\n    return this.close(true);\n  }\n  /**\n   * Issues a request to lock the conversation\n   * @param cb\n   * @param err\n   */\n  lockMeetingAsync(cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"lock\")), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getLockCommand(true), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to mute the meeting\n   * @param cb\n   * @param err\n   */\n  muteAllParticipantsAsync(cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      // check the user's permissions\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"mute\")), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(true), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to mute a participant in the meeting\n   * @param userId\n   * @param cb\n   * @param err\n   */\n  muteParticipantAsync(userId, cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts_js_1.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      // check the connection is open (host + participant can perform the mute command)\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      }\n      // if not host, check the participant is not muting another participant\n      if (!this.me.isHost && this.me.id !== userId) {\n        this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\n      }\n      // check the user exists\n      const exists = this.privParticipants.getParticipantIndex(userId);\n      if (exists === -1) {\n        this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, true), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to remove a participant from the conversation\n   * @param userId\n   * @param cb\n   * @param err\n   */\n  removeParticipantAsync(userId, cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      if (!!this.privTranscriberRecognizer && userId.hasOwnProperty(\"id\")) {\n        // Assume this is a transcription participant\n        Exports_js_2.marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId), cb, err);\n      } else {\n        Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n        if (!this.canSendAsHost) {\n          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"remove\")), err);\n        }\n        let participantId = \"\";\n        if (typeof userId === \"string\") {\n          participantId = userId;\n        } else if (userId.hasOwnProperty(\"id\")) {\n          const participant = userId;\n          participantId = participant.id;\n        } else if (userId.hasOwnProperty(\"userId\")) {\n          const user = userId;\n          participantId = user.userId;\n        }\n        Contracts_js_1.Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n        // check the participant exists\n        const index = this.participants.findIndex(p => p.id === participantId);\n        if (index === -1) {\n          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n        }\n        if (!!this.privConversationRecognizer) {\n          this.privConversationRecognizer.sendRequest(this.getEjectCommand(participantId), () => {\n            this.handleCallback(cb, err);\n          }, error => {\n            this.handleError(error, err);\n          });\n        }\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to unlock the meeting\n   * @param cb\n   * @param err\n   */\n  unlockMeetingAsync(cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unlock\")), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getLockCommand(false), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to unmute all participants in the meeting\n   * @param cb\n   * @param err\n   */\n  unmuteAllParticipantsAsync(cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unmute all\")), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(false), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to unmute a participant in the meeting\n   * @param userId\n   * @param cb\n   * @param err\n   */\n  unmuteParticipantAsync(userId, cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts_js_1.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      // check the connection is open (host + participant can perform the mute command)\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      }\n      // if not host, check the participant is not muting another participant\n      if (!this.me.isHost && this.me.id !== userId) {\n        this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\n      }\n      // check the user exists\n      const exists = this.privParticipants.getParticipantIndex(userId);\n      if (exists === -1) {\n        this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, false), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Send a text message\n   * @param message\n   * @param cb\n   * @param err\n   */\n  sendTextMessageAsync(message, cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts_js_1.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", \"message\"));\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      }\n      // TODO: is a max length check required?\n      if (message.length > this.privTextMessageMaxLength) {\n        this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"message length\")), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getMessageCommand(message), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Set translated to languages\n   * @param {string[]} languages - languages to translate to\n   * @param cb\n   * @param err\n   */\n  setTranslatedLanguagesAsync(languages, cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts_js_1.Contracts.throwIfArrayEmptyOrWhitespace(languages, this.privErrors.invalidArgs.replace(\"{arg}\", \"languages\"));\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(languages), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Change nickname\n   * @param {string} nickname - new nickname for the room\n   * @param cb\n   * @param err\n   */\n  changeNicknameAsync(nickname, cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(nickname), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n    this.privIsDisposed = true;\n    if (!!this.config) {\n      this.config.close();\n    }\n    this.privConfig = undefined;\n    this.privLanguage = undefined;\n    this.privProperties = undefined;\n    this.privRoom = undefined;\n    this.privToken = undefined;\n    this.privManager = undefined;\n    this.privIsConnected = false;\n    this.privIsReady = false;\n    this.privParticipants = undefined;\n  }\n  connectTranscriberRecognizer(recognizer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privTranscriberRecognizer) {\n        yield this.privTranscriberRecognizer.close();\n      }\n      yield recognizer.enforceAudioGating();\n      this.privTranscriberRecognizer = recognizer;\n      this.privTranscriberRecognizer.meeting = this;\n    });\n  }\n  getKeepAlive() {\n    const nickname = !!this.me ? this.me.displayName : \"default_nickname\";\n    return JSON.stringify({\n      id: \"0\",\n      nickname,\n      participantId: this.privRoom.participantId,\n      roomId: this.privRoom.roomId,\n      type: Exports_js_1.ConversationTranslatorMessageTypes.keepAlive\n    });\n  }\n  /* eslint-enable @typescript-eslint/typedef */\n  addParticipantImplAsync(participant) {\n    const newParticipant = this.privParticipants.addOrUpdateParticipant(participant);\n    if (newParticipant !== undefined) {\n      if (!!this.privTranscriberRecognizer) {\n        const meetingInfo = this.meetingInfo;\n        meetingInfo.participants = [participant];\n        return this.privTranscriberRecognizer.pushMeetingEvent(meetingInfo, \"join\");\n      }\n    }\n  }\n  removeParticipantImplAsync(participant) {\n    this.privParticipants.deleteParticipant(participant.id);\n    const meetingInfo = this.meetingInfo;\n    meetingInfo.participants = [participant];\n    return this.privTranscriberRecognizer.pushMeetingEvent(meetingInfo, \"leave\");\n  }\n  close(dispose) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.privIsConnected = false;\n        yield (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.close();\n        this.privConversationRecognizer = undefined;\n        if (!!this.privConversationTranslator) {\n          this.privConversationTranslator.dispose();\n        }\n      } catch (e) {\n        // ignore error\n        throw e;\n      }\n      if (dispose) {\n        this.dispose();\n      }\n    });\n  }\n  /** Helpers */\n  handleCallback(cb, err) {\n    if (!!cb) {\n      try {\n        cb();\n      } catch (e) {\n        if (!!err) {\n          err(e);\n        }\n      }\n      cb = undefined;\n    }\n  }\n  handleError(error, err) {\n    if (!!err) {\n      if (error instanceof Error) {\n        const typedError = error;\n        err(typedError.name + \": \" + typedError.message);\n      } else {\n        err(error);\n      }\n    }\n  }\n  /** Participant Helpers */\n  toParticipants(includeHost) {\n    const participants = this.privParticipants.participants.map(p => this.toParticipant(p));\n    if (!includeHost) {\n      return participants.filter(p => p.isHost === false);\n    } else {\n      return participants;\n    }\n  }\n  toParticipant(p) {\n    return new Exports_js_3.Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage, p.voice);\n  }\n  getMuteAllCommand(isMuted) {\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"meetingd\");\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    return JSON.stringify({\n      command: Exports_js_1.ConversationTranslatorCommandTypes.setMuteAll,\n      participantId: this.privRoom.participantId,\n      roomid: this.privRoom.roomId,\n      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,\n      value: isMuted\n    });\n  }\n  getMuteCommand(participantId, isMuted) {\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\n    return JSON.stringify({\n      command: Exports_js_1.ConversationTranslatorCommandTypes.setMute,\n      // eslint-disable-next-line object-shorthand\n      participantId: participantId,\n      roomid: this.privRoom.roomId,\n      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,\n      value: isMuted\n    });\n  }\n  getLockCommand(isLocked) {\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"meetingId\");\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    return JSON.stringify({\n      command: Exports_js_1.ConversationTranslatorCommandTypes.setLockState,\n      participantId: this.privRoom.participantId,\n      roomid: this.privRoom.roomId,\n      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,\n      value: isLocked\n    });\n  }\n  getEjectCommand(participantId) {\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"meetingId\");\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\n    return JSON.stringify({\n      command: Exports_js_1.ConversationTranslatorCommandTypes.ejectParticipant,\n      // eslint-disable-next-line object-shorthand\n      participantId: participantId,\n      roomid: this.privRoom.roomId,\n      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand\n    });\n  }\n  getSetTranslateToLanguagesCommand(languages) {\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"meetingId\");\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    return JSON.stringify({\n      command: Exports_js_1.ConversationTranslatorCommandTypes.setTranslateToLanguages,\n      participantId: this.privRoom.participantId,\n      roomid: this.privRoom.roomId,\n      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,\n      value: languages\n    });\n  }\n  getChangeNicknameCommand(nickname) {\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"meetingId\");\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    return JSON.stringify({\n      command: Exports_js_1.ConversationTranslatorCommandTypes.changeNickname,\n      nickname,\n      participantId: this.privRoom.participantId,\n      roomid: this.privRoom.roomId,\n      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,\n      value: nickname\n    });\n  }\n  getMessageCommand(message) {\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"meetingId\");\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(message, \"message\");\n    return JSON.stringify({\n      participantId: this.privRoom.participantId,\n      roomId: this.privRoom.roomId,\n      text: message,\n      type: Exports_js_1.ConversationTranslatorMessageTypes.instantMessage\n    });\n  }\n}\nexports.MeetingImpl = MeetingImpl;\n\n//# sourceMappingURL=Meeting.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}