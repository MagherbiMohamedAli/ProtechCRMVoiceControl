{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConversationTranslatorRecognizer = exports.ConversationRecognizerFactory = void 0;\n// eslint-disable-next-line max-classes-per-file\nconst Exports_js_1 = require(\"../../common.speech/Exports.js\");\nconst Exports_js_2 = require(\"../../common/Exports.js\");\nconst Contracts_js_1 = require(\"../../sdk/Contracts.js\");\nconst Exports_js_3 = require(\"../../sdk/Exports.js\");\nconst ConversationConnectionFactory_js_1 = require(\"./ConversationConnectionFactory.js\");\nconst ConversationServiceAdapter_js_1 = require(\"./ConversationServiceAdapter.js\");\nclass ConversationRecognizerFactory {\n  static fromConfig(conversation, speechConfig, audioConfig) {\n    return new ConversationTranslatorRecognizer(conversation, speechConfig, audioConfig);\n  }\n}\nexports.ConversationRecognizerFactory = ConversationRecognizerFactory;\n/**\n * Sends messages to the Conversation Translator websocket and listens for incoming events containing websocket messages.\n * Based off the recognizers in the SDK folder.\n */\nclass ConversationTranslatorRecognizer extends Exports_js_3.Recognizer {\n  constructor(conversation, speechConfig, audioConfig) {\n    const serviceConfigImpl = speechConfig;\n    Contracts_js_1.Contracts.throwIfNull(serviceConfigImpl, \"speechConfig\");\n    const conversationImpl = conversation;\n    Contracts_js_1.Contracts.throwIfNull(conversationImpl, \"conversationImpl\");\n    super(audioConfig, serviceConfigImpl.properties, new ConversationConnectionFactory_js_1.ConversationConnectionFactory());\n    this.privConversation = conversationImpl;\n    this.privIsDisposed = false;\n    this.privProperties = serviceConfigImpl.properties.clone();\n    this.privConnection = Exports_js_3.Connection.fromRecognizer(this);\n    const webWorkerLoadType = this.privProperties.getProperty(Exports_js_3.PropertyId.WebWorkerLoadType, \"on\").toLowerCase();\n    if (webWorkerLoadType === \"on\" && typeof Blob !== \"undefined\" && typeof Worker !== \"undefined\") {\n      this.privSetTimeout = Exports_js_2.Timeout.setTimeout;\n      this.privClearTimeout = Exports_js_2.Timeout.clearTimeout;\n    } else {\n      if (typeof window !== \"undefined\") {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.privSetTimeout = window.setTimeout.bind(window);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.privClearTimeout = window.clearTimeout.bind(window);\n      } else {\n        this.privSetTimeout = setTimeout;\n        this.privClearTimeout = clearTimeout;\n      }\n    }\n  }\n  set connected(cb) {\n    this.privConnection.connected = cb;\n  }\n  set disconnected(cb) {\n    this.privConnection.disconnected = cb;\n  }\n  /**\n   * Return the speech language used by the recognizer\n   */\n  get speechRecognitionLanguage() {\n    return this.privSpeechRecognitionLanguage;\n  }\n  /**\n   * Return the properties for the recognizer\n   */\n  get properties() {\n    return this.privProperties;\n  }\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n  /**\n   * Connect to the recognizer\n   * @param token\n   */\n  connect(token, cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts_js_1.Contracts.throwIfNullOrWhitespace(token, \"token\");\n      this.privReco.conversationTranslatorToken = token;\n      this.resetConversationTimeout();\n      this.privReco.connectAsync(cb, err);\n    } catch (error) {\n      if (!!err) {\n        if (error instanceof Error) {\n          const typedError = error;\n          err(typedError.name + \": \" + typedError.message);\n        } else {\n          err(error);\n        }\n      }\n    }\n  }\n  /**\n   * Disconnect from the recognizer\n   */\n  disconnect(cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      if (this.privTimeoutToken !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this.privClearTimeout(this.privTimeoutToken);\n      }\n      this.privReco.disconnect().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n    } catch (error) {\n      if (!!err) {\n        if (error instanceof Error) {\n          const typedError = error;\n          err(typedError.name + \": \" + typedError.message);\n        } else {\n          err(error);\n        }\n      }\n      // Destroy the recognizer.\n      this.dispose(true).catch(reason => {\n        Exports_js_2.Events.instance.onEvent(new Exports_js_2.BackgroundEvent(reason));\n      });\n    }\n  }\n  /**\n   * Send the mute all participants command to the websocket\n   * @param conversationId\n   * @param participantId\n   * @param isMuted\n   */\n  sendRequest(command, cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);\n      this.sendMessage(command, cb, err);\n    } catch (error) {\n      if (!!err) {\n        if (error instanceof Error) {\n          const typedError = error;\n          err(typedError.name + \": \" + typedError.message);\n        } else {\n          err(error);\n        }\n      }\n      // Destroy the recognizer.\n      this.dispose(true).catch(reason => {\n        Exports_js_2.Events.instance.onEvent(new Exports_js_2.BackgroundEvent(reason));\n      });\n    }\n  }\n  /**\n   * Handle update of service auth token (#694)\n   */\n  onToken(token) {\n    this.privConversation.onToken(token);\n  }\n  /**\n   * Close and dispose the recognizer\n   */\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privIsDisposed) {\n        if (!!this.privConnection) {\n          this.privConnection.closeConnection();\n          this.privConnection.close();\n        }\n        this.privConnection = undefined;\n        yield this.dispose(true);\n      }\n    });\n  }\n  /**\n   * Dispose the recognizer\n   * @param disposing\n   */\n  dispose(disposing) {\n    const _super = Object.create(null, {\n      dispose: {\n        get: () => super.dispose\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privIsDisposed) {\n        return;\n      }\n      if (disposing) {\n        if (this.privTimeoutToken !== undefined) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n          this.privClearTimeout(this.privTimeoutToken);\n        }\n        this.privIsDisposed = true;\n        if (!!this.privConnection) {\n          this.privConnection.closeConnection();\n          this.privConnection.close();\n          this.privConnection = undefined;\n        }\n        yield _super.dispose.call(this, disposing);\n      }\n    });\n  }\n  /**\n   * Create the config for the recognizer\n   * @param speechConfig\n   */\n  createRecognizerConfig(speechConfig) {\n    return new Exports_js_1.RecognizerConfig(speechConfig, this.privProperties);\n  }\n  /**\n   * Create the service recognizer.\n   * The audio source is redundnant here but is required by the implementation.\n   * @param authentication\n   * @param connectionFactory\n   * @param audioConfig\n   * @param recognizerConfig\n   */\n  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {\n    const audioSource = audioConfig;\n    return new ConversationServiceAdapter_js_1.ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, this);\n  }\n  sendMessage(msg, cb, err) {\n    const withAsync = this.privReco;\n    const PromiseToEmptyCallback = (promise, cb, err) => {\n      if (promise !== undefined) {\n        promise.then(() => {\n          try {\n            if (!!cb) {\n              cb();\n            }\n          } catch (e) {\n            if (!!err) {\n              err(`'Unhandled error on promise callback: ${e}'`);\n            }\n          }\n        }, reason => {\n          try {\n            if (!!err) {\n              err(reason);\n            }\n            // eslint-disable-next-line no-empty\n          } catch (error) {}\n        });\n      } else {\n        if (!!err) {\n          err(\"Null promise\");\n        }\n      }\n    };\n    PromiseToEmptyCallback(withAsync.sendMessageAsync(msg), cb, err);\n    this.resetConversationTimeout();\n  }\n  resetConversationTimeout() {\n    if (this.privTimeoutToken !== undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      this.privClearTimeout(this.privTimeoutToken);\n    }\n    this.privTimeoutToken = this.privSetTimeout(() => {\n      this.sendRequest(this.privConversation.getKeepAlive());\n    }, 60000);\n  }\n}\nexports.ConversationTranslatorRecognizer = ConversationTranslatorRecognizer;\n\n//# sourceMappingURL=ConversationTranslatorRecognizer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}