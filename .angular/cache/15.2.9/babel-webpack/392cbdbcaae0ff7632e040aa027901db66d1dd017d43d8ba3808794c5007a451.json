{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VoiceServiceRecognizer = void 0;\nconst Exports_js_1 = require(\"../common.browser/Exports.js\");\nconst Exports_js_2 = require(\"../common/Exports.js\");\nconst Exports_js_3 = require(\"../sdk/Exports.js\");\nconst Exports_js_4 = require(\"./Exports.js\");\nconst SpeechConnectionMessage_Internal_js_1 = require(\"./SpeechConnectionMessage.Internal.js\");\n// eslint-disable-next-line max-classes-per-file\nclass VoiceServiceRecognizer extends Exports_js_4.ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\n    this.privDeferralMap = new Exports_js_2.DeferralMap();\n    this.privSpeakerAudioSource = audioSource;\n    this.sendPrePayloadJSONOverride = () => this.noOp();\n  }\n  set SpeakerAudioSource(audioSource) {\n    this.privSpeakerAudioSource = audioSource;\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    let processed = false;\n    const resultProps = new Exports_js_3.PropertyCollection();\n    if (connectionMessage.messageType === Exports_js_2.MessageType.Text) {\n      resultProps.setProperty(Exports_js_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n    }\n    switch (connectionMessage.path.toLowerCase()) {\n      // Profile management response for create, fetch, delete, reset\n      case \"speaker.profiles\":\n        const response = JSON.parse(connectionMessage.textBody);\n        switch (response.operation.toLowerCase()) {\n          case \"create\":\n            this.handleCreateResponse(response, connectionMessage.requestId);\n            break;\n          case \"delete\":\n          case \"reset\":\n            this.handleResultResponse(response, connectionMessage.requestId);\n            break;\n          case \"fetch\":\n            const enrollmentResponse = JSON.parse(connectionMessage.textBody);\n            this.handleFetchResponse(enrollmentResponse, connectionMessage.requestId);\n            break;\n          default:\n            break;\n        }\n        processed = true;\n        break;\n      // Activation and authorization phrase response\n      case \"speaker.phrases\":\n        const phraseResponse = JSON.parse(connectionMessage.textBody);\n        this.handlePhrasesResponse(phraseResponse, connectionMessage.requestId);\n        processed = true;\n        break;\n      // Enrollment response\n      case \"speaker.profile.enrollment\":\n        const enrollmentResponse = JSON.parse(connectionMessage.textBody);\n        const result = new Exports_js_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(!!enrollmentResponse.enrollment ? enrollmentResponse.enrollment.enrollmentStatus : enrollmentResponse.status.statusCode), !!enrollmentResponse.enrollment ? JSON.stringify(enrollmentResponse.enrollment) : undefined, enrollmentResponse.status.reason);\n        if (!!this.privDeferralMap.getId(connectionMessage.requestId)) {\n          this.privDeferralMap.complete(connectionMessage.requestId, result);\n        }\n        this.privRequestSession.onSpeechEnded();\n        processed = true;\n        break;\n      default:\n        break;\n    }\n    const defferal = new Exports_js_2.Deferred();\n    defferal.resolve(processed);\n    return defferal.promise;\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    const properties = new Exports_js_3.PropertyCollection();\n    // const enrollmentResponse: EnrollmentResponse = JSON.parse(connectionMessage.textBody) as EnrollmentResponse;\n    properties.setProperty(Exports_js_4.CancellationErrorCodePropertyName, Exports_js_3.CancellationErrorCode[errorCode]);\n    const result = new Exports_js_3.VoiceProfileEnrollmentResult(Exports_js_3.ResultReason.Canceled, error, error);\n    if (!!this.privDeferralMap.getId(requestId)) {\n      this.privDeferralMap.complete(requestId, result);\n    }\n  }\n  createProfile(profileType, locale) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n      this.voiceProfileType = profileType.toString();\n      const conPromise = this.connectImpl();\n      try {\n        const createProfileDeferral = new Exports_js_2.Deferred();\n        yield conPromise;\n        yield this.sendCreateProfile(createProfileDeferral, profileType, locale);\n        void this.receiveMessage();\n        return createProfileDeferral.promise;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  resetProfile(profile) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.voiceProfileType = profile.profileType.toString();\n      return this.sendCommonRequest(\"reset\", profile.profileType, profile);\n    });\n  }\n  deleteProfile(profile) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.voiceProfileType = profile.profileType.toString();\n      return this.sendCommonRequest(\"delete\", profile.profileType, profile);\n    });\n  }\n  retrieveEnrollmentResult(profile) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.voiceProfileType = profile.profileType.toString();\n      this.privExpectedProfileId = profile.profileId;\n      return this.sendCommonRequest(\"fetch\", profile.profileType, profile);\n    });\n  }\n  getAllProfiles(profileType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.voiceProfileType = profileType.toString();\n      return this.sendCommonRequest(\"fetch\", profileType);\n    });\n  }\n  getActivationPhrases(profileType, lang) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.voiceProfileType = profileType.toString();\n      // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n      const conPromise = this.connectImpl();\n      try {\n        const getPhrasesDeferral = new Exports_js_2.Deferred();\n        yield conPromise;\n        yield this.sendPhrasesRequest(getPhrasesDeferral, profileType, lang);\n        void this.receiveMessage();\n        return getPhrasesDeferral.promise;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  enrollProfile(profile) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.voiceProfileType = profile.profileType.toString();\n      const enrollmentDeferral = new Exports_js_2.Deferred();\n      this.privRequestSession.startNewRecognition();\n      this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events);\n      this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\n      // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n      const conPromise = this.connectImpl();\n      const preAudioPromise = this.sendPreAudioMessages(profile, enrollmentDeferral);\n      const node = yield this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId);\n      const format = yield this.privSpeakerAudioSource.format;\n      const deviceInfo = yield this.privSpeakerAudioSource.deviceInfo;\n      const audioNode = new Exports_js_1.ReplayableAudioNode(node, format.avgBytesPerSec);\n      yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n      this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {\n        source: deviceInfo\n      };\n      try {\n        yield conPromise;\n        yield preAudioPromise;\n      } catch (err) {\n        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.ConnectionFailure, err);\n      }\n      const sessionStartEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);\n      if (!!this.privRecognizer.sessionStarted) {\n        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n      }\n      void this.receiveMessage();\n      const audioSendPromise = this.sendAudio(audioNode);\n      // /* eslint-disable no-empty */\n      audioSendPromise.then(() => {}, error => {\n        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);\n      });\n      return enrollmentDeferral.promise;\n    });\n  }\n  sendPreAudioMessages(profile, enrollmentDeferral) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      this.privRequestSession.onSpeechContext();\n      this.privDeferralMap.add(this.privRequestSession.requestId, enrollmentDeferral);\n      yield this.sendBaseRequest(connection, \"enroll\", this.scenarioFrom(profile.profileType), profile);\n    });\n  }\n  sendPhrasesRequest(getPhrasesDeferral, profileType, locale) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      this.privRequestSession.onSpeechContext();\n      this.privDeferralMap.add(this.privRequestSession.requestId, getPhrasesDeferral);\n      const scenario = this.scenarioFrom(profileType);\n      const profileCreateRequest = {\n        locale,\n        scenario\n      };\n      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, \"speaker.profile.phrases\", this.privRequestSession.requestId, \"application/json; charset=utf-8\", JSON.stringify(profileCreateRequest)));\n    });\n  }\n  sendCreateProfile(createProfileDeferral, profileType, locale) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      this.privRequestSession.onSpeechContext();\n      this.privDeferralMap.add(this.privRequestSession.requestId, createProfileDeferral);\n      const scenario = profileType === Exports_js_3.VoiceProfileType.TextIndependentIdentification ? \"TextIndependentIdentification\" : profileType === Exports_js_3.VoiceProfileType.TextIndependentVerification ? \"TextIndependentVerification\" : \"TextDependentVerification\";\n      const profileCreateRequest = {\n        locale,\n        number: \"1\",\n        scenario\n      };\n      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, \"speaker.profile.create\", this.privRequestSession.requestId, \"application/json; charset=utf-8\", JSON.stringify(profileCreateRequest)));\n    });\n  }\n  sendCommonRequest(operation, profileType, profile = undefined) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n      const conPromise = this.connectImpl();\n      try {\n        const deferral = new Exports_js_2.Deferred();\n        this.privRequestSession.onSpeechContext();\n        yield conPromise;\n        const connection = yield this.fetchConnection();\n        this.privDeferralMap.add(this.privRequestSession.requestId, deferral);\n        yield this.sendBaseRequest(connection, operation, this.scenarioFrom(profileType), profile);\n        void this.receiveMessage();\n        return deferral.promise;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  sendBaseRequest(connection, operation, scenario, profile) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const profileRequest = {\n        scenario\n      };\n      if (!!profile) {\n        profileRequest.profileIds = [profile.profileId];\n      } else {\n        profileRequest.maxPageSize = -1;\n      }\n      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, `speaker.profile.${operation}`, this.privRequestSession.requestId, \"application/json; charset=utf-8\", JSON.stringify(profileRequest)));\n    });\n  }\n  extractSpeakerContext(model) {\n    return {\n      features: {\n        interimResult: \"enabled\",\n        progressiveDetection: \"disabled\"\n      },\n      profileIds: model.profileIds,\n      scenario: model.scenario\n    };\n  }\n  handlePhrasesResponse(response, requestId) {\n    if (!!this.privDeferralMap.getId(requestId)) {\n      if (response.status.statusCode.toLowerCase() !== \"success\") {\n        const reason = Exports_js_3.ResultReason.Canceled;\n        const result = new Exports_js_3.VoiceProfilePhraseResult(reason, response.status.statusCode, response.passPhraseType, []);\n        this.privDeferralMap.complete(requestId, result);\n      } else if (!!response.phrases && response.phrases.length > 0) {\n        const reason = Exports_js_3.ResultReason.EnrollingVoiceProfile;\n        const result = new Exports_js_3.VoiceProfilePhraseResult(reason, response.status.statusCode, response.passPhraseType, response.phrases);\n        this.privDeferralMap.complete(requestId, result);\n      } else {\n        throw new Error(\"Voice Profile get activation phrases failed, no phrases received\");\n      }\n    } else {\n      throw new Error(`Voice Profile get activation phrases request for requestID ${requestId} not found`);\n    }\n  }\n  handleCreateResponse(response, requestId) {\n    if (!!response.profiles && response.profiles.length > 0) {\n      if (!!this.privDeferralMap.getId(requestId)) {\n        const profileIds = response.profiles.map(profile => profile.profileId);\n        this.privDeferralMap.complete(requestId, profileIds);\n      } else {\n        throw new Error(`Voice Profile create request for requestID ${requestId} not found`);\n      }\n    } else {\n      throw new Error(\"Voice Profile create failed, no profile id received\");\n    }\n  }\n  handleResultResponse(response, requestId) {\n    if (!!this.privDeferralMap.getId(requestId)) {\n      const successReason = response.operation.toLowerCase() === \"delete\" ? Exports_js_3.ResultReason.DeletedVoiceProfile : Exports_js_3.ResultReason.ResetVoiceProfile;\n      const reason = response.status.statusCode.toLowerCase() === \"success\" ? successReason : Exports_js_3.ResultReason.Canceled;\n      const result = new Exports_js_3.VoiceProfileResult(reason, `statusCode: ${response.status.statusCode}, errorDetails: ${response.status.reason}`);\n      this.privDeferralMap.complete(requestId, result);\n    } else {\n      throw new Error(`Voice Profile create request for requestID ${requestId} not found`);\n    }\n  }\n  handleFetchResponse(enrollmentResponse, requestId) {\n    if (!!this.privDeferralMap.getId(requestId) && !!enrollmentResponse.profiles[0]) {\n      if (!!this.privExpectedProfileId && enrollmentResponse.profiles.length === 1 && enrollmentResponse.profiles[0].profileId === this.privExpectedProfileId) {\n        this.privExpectedProfileId = undefined;\n        const profileInfo = enrollmentResponse.profiles[0];\n        const result = new Exports_js_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(profileInfo.enrollmentStatus), JSON.stringify(profileInfo), enrollmentResponse.status.reason);\n        this.privDeferralMap.complete(requestId, result);\n      } else if (enrollmentResponse.profiles.length > 0) {\n        const iProfiles = enrollmentResponse.profiles;\n        const profileResults = [];\n        for (const profile of iProfiles) {\n          profileResults.push(new Exports_js_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(profile.enrollmentStatus), JSON.stringify(profile), enrollmentResponse.status.reason));\n        }\n        this.privDeferralMap.complete(requestId, profileResults);\n      }\n    } else {\n      throw new Error(`Voice Profile fetch request for requestID ${requestId} not found`);\n    }\n  }\n  enrollmentReasonFrom(statusCode) {\n    switch (statusCode.toLowerCase()) {\n      case \"enrolled\":\n        return Exports_js_3.ResultReason.EnrolledVoiceProfile;\n      case \"invalidlocale\":\n      case \"invalidphrase\":\n      case \"invalidaudioformat\":\n      case \"invalidscenario\":\n      case \"invalidprofilecount\":\n      case \"invalidoperation\":\n      case \"audiotooshort\":\n      case \"audiotoolong\":\n      case \"toomanyenrollments\":\n      case \"storageconflict\":\n      case \"profilenotfound\":\n      case \"incompatibleprofiles\":\n      case \"incompleteenrollment\":\n        return Exports_js_3.ResultReason.Canceled;\n      default:\n        return Exports_js_3.ResultReason.EnrollingVoiceProfile;\n    }\n  }\n  scenarioFrom(profileType) {\n    return profileType === Exports_js_3.VoiceProfileType.TextIndependentIdentification ? \"TextIndependentIdentification\" : profileType === Exports_js_3.VoiceProfileType.TextIndependentVerification ? \"TextIndependentVerification\" : \"TextDependentVerification\";\n  }\n}\nexports.VoiceServiceRecognizer = VoiceServiceRecognizer;\n\n//# sourceMappingURL=VoiceServiceRecognizer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}