{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseAudioPlayer = void 0;\nconst Error_js_1 = require(\"../../common/Error.js\");\nconst Exports_js_1 = require(\"../Exports.js\");\nconst AudioStreamFormat_js_1 = require(\"./AudioStreamFormat.js\");\n/**\n * Base audio player class\n * TODO: Plays only PCM for now.\n * @class\n */\nclass BaseAudioPlayer {\n  /**\n   * Creates and initializes an instance of this class.\n   * @constructor\n   * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.\n   */\n  constructor(audioFormat) {\n    this.audioContext = null;\n    this.gainNode = null;\n    this.autoUpdateBufferTimer = 0;\n    if (audioFormat === undefined) {\n      audioFormat = Exports_js_1.AudioStreamFormat.getDefaultInputFormat();\n    }\n    this.init(audioFormat);\n  }\n  /**\n   * play Audio sample\n   * @param newAudioData audio data to be played.\n   */\n  playAudioSample(newAudioData, cb, err) {\n    try {\n      this.ensureInitializedContext();\n      const audioData = this.formatAudioData(newAudioData);\n      const newSamplesData = new Float32Array(this.samples.length + audioData.length);\n      newSamplesData.set(this.samples, 0);\n      newSamplesData.set(audioData, this.samples.length);\n      this.samples = newSamplesData;\n      if (!!cb) {\n        cb();\n      }\n    } catch (e) {\n      if (!!err) {\n        err(e);\n      }\n    }\n  }\n  /**\n   * stops audio and clears the buffers\n   */\n  stopAudio(cb, err) {\n    if (this.audioContext !== null) {\n      this.samples = new Float32Array();\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      clearInterval(this.autoUpdateBufferTimer);\n      this.audioContext.close().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n      this.audioContext = null;\n    }\n  }\n  init(audioFormat) {\n    this.audioFormat = audioFormat;\n    this.samples = new Float32Array();\n  }\n  ensureInitializedContext() {\n    if (this.audioContext === null) {\n      this.createAudioContext();\n      const timerPeriod = 200;\n      this.autoUpdateBufferTimer = setInterval(() => {\n        this.updateAudioBuffer();\n      }, timerPeriod);\n    }\n  }\n  createAudioContext() {\n    // new ((window as any).AudioContext || (window as any).webkitAudioContext)();\n    this.audioContext = AudioStreamFormat_js_1.AudioStreamFormatImpl.getAudioContext();\n    // TODO: Various examples shows this gain node, it does not seem to be needed unless we plan\n    // to control the volume, not likely\n    this.gainNode = this.audioContext.createGain();\n    this.gainNode.gain.value = 1;\n    this.gainNode.connect(this.audioContext.destination);\n    this.startTime = this.audioContext.currentTime;\n  }\n  formatAudioData(audioData) {\n    switch (this.audioFormat.bitsPerSample) {\n      case 8:\n        return this.formatArrayBuffer(new Int8Array(audioData), 128);\n      case 16:\n        return this.formatArrayBuffer(new Int16Array(audioData), 32768);\n      case 32:\n        return this.formatArrayBuffer(new Int32Array(audioData), 2147483648);\n      default:\n        throw new Error_js_1.InvalidOperationError(\"Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time\");\n    }\n  }\n  formatArrayBuffer(audioData, maxValue) {\n    const float32Data = new Float32Array(audioData.length);\n    for (let i = 0; i < audioData.length; i++) {\n      float32Data[i] = audioData[i] / maxValue;\n    }\n    return float32Data;\n  }\n  updateAudioBuffer() {\n    if (this.samples.length === 0) {\n      return;\n    }\n    const channelCount = this.audioFormat.channels;\n    const bufferSource = this.audioContext.createBufferSource();\n    const frameCount = this.samples.length / channelCount;\n    const audioBuffer = this.audioContext.createBuffer(channelCount, frameCount, this.audioFormat.samplesPerSec);\n    // TODO: Should we do the conversion in the pushAudioSample instead?\n    for (let channel = 0; channel < channelCount; channel++) {\n      // Fill in individual channel data\n      let channelOffset = channel;\n      const audioData = audioBuffer.getChannelData(channel);\n      for (let i = 0; i < this.samples.length; i++, channelOffset += channelCount) {\n        audioData[i] = this.samples[channelOffset];\n      }\n    }\n    if (this.startTime < this.audioContext.currentTime) {\n      this.startTime = this.audioContext.currentTime;\n    }\n    bufferSource.buffer = audioBuffer;\n    bufferSource.connect(this.gainNode);\n    bufferSource.start(this.startTime);\n    // Make sure we play the next sample after the current one.\n    this.startTime += audioBuffer.duration;\n    // Clear the samples for the next pushed data.\n    this.samples = new Float32Array();\n  }\n  playAudio(audioData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.audioContext === null) {\n        this.createAudioContext();\n      }\n      const source = this.audioContext.createBufferSource();\n      const destination = this.audioContext.destination;\n      yield this.audioContext.decodeAudioData(audioData, newBuffer => {\n        source.buffer = newBuffer;\n        source.connect(destination);\n        source.start(0);\n      });\n    });\n  }\n}\nexports.BaseAudioPlayer = BaseAudioPlayer;\n\n//# sourceMappingURL=BaseAudioPlayer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}