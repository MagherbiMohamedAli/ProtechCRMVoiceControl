{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IntentServiceRecognizer = void 0;\nconst Exports_js_1 = require(\"../common/Exports.js\");\nconst Exports_js_2 = require(\"../sdk/Exports.js\");\nconst Exports_js_3 = require(\"./Exports.js\");\n// eslint-disable-next-line max-classes-per-file\nclass IntentServiceRecognizer extends Exports_js_3.ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\n    this.privIntentRecognizer = recognizer;\n    this.privIntentDataSent = false;\n  }\n  setIntents(addedIntents, umbrellaIntent) {\n    this.privAddedLmIntents = addedIntents;\n    this.privUmbrellaIntent = umbrellaIntent;\n    this.privIntentDataSent = true;\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    let result;\n    let ev;\n    let processed = false;\n    const resultProps = new Exports_js_2.PropertyCollection();\n    if (connectionMessage.messageType === Exports_js_1.MessageType.Text) {\n      resultProps.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n    }\n    switch (connectionMessage.path.toLowerCase()) {\n      case \"speech.hypothesis\":\n        const speechHypothesis = Exports_js_3.SpeechHypothesis.fromJSON(connectionMessage.textBody);\n        result = new Exports_js_2.IntentRecognitionResult(undefined, this.privRequestSession.requestId, Exports_js_2.ResultReason.RecognizingIntent, speechHypothesis.Text, speechHypothesis.Duration, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, speechHypothesis.Language, speechHypothesis.LanguageDetectionConfidence, undefined, connectionMessage.textBody, resultProps);\n        this.privRequestSession.onHypothesis(result.offset);\n        ev = new Exports_js_2.IntentRecognitionEventArgs(result, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n        if (!!this.privIntentRecognizer.recognizing) {\n          try {\n            this.privIntentRecognizer.recognizing(this.privIntentRecognizer, ev);\n            /* eslint-disable no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n        break;\n      case \"speech.phrase\":\n        const simple = Exports_js_3.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n        result = new Exports_js_2.IntentRecognitionResult(undefined, this.privRequestSession.requestId, Exports_js_3.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus), simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, undefined, connectionMessage.textBody, resultProps);\n        ev = new Exports_js_2.IntentRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n        const sendEvent = () => {\n          if (!!this.privIntentRecognizer.recognized) {\n            try {\n              this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);\n              /* eslint-disable no-empty */\n            } catch (error) {\n              // Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n          // report result to promise.\n          if (!!this.privSuccessCallback) {\n            try {\n              this.privSuccessCallback(result);\n            } catch (e) {\n              if (!!this.privErrorCallback) {\n                this.privErrorCallback(e);\n              }\n            }\n            // Only invoke the call back once.\n            // and if it's successful don't invoke the\n            // error after that.\n            this.privSuccessCallback = undefined;\n            this.privErrorCallback = undefined;\n          }\n        };\n        // If intent data was sent, the terminal result for this recognizer is an intent being found.\n        // If no intent data was sent, the terminal event is speech recognition being successful.\n        if (false === this.privIntentDataSent || Exports_js_2.ResultReason.NoMatch === ev.result.reason) {\n          // Advance the buffers.\n          this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);\n          sendEvent();\n        } else {\n          // Squirrel away the args, when the response event arrives it will build upon them\n          // and then return\n          this.privPendingIntentArgs = ev;\n        }\n        processed = true;\n        break;\n      case \"response\":\n        // Response from LUIS\n        ev = this.privPendingIntentArgs;\n        this.privPendingIntentArgs = undefined;\n        if (undefined === ev) {\n          if (\"\" === connectionMessage.textBody) {\n            // This condition happens if there is nothing but silence in the\n            // audio sent to the service.\n            return;\n          }\n          // Odd... Not sure this can happen\n          ev = new Exports_js_2.IntentRecognitionEventArgs(new Exports_js_2.IntentRecognitionResult(), 0, this.privRequestSession.sessionId);\n        }\n        const intentResponse = Exports_js_3.IntentResponse.fromJSON(connectionMessage.textBody);\n        // If LUIS didn't return anything, send the existing event, else\n        // modify it to show the match.\n        // See if the intent found is in the list of intents asked for.\n        if (null !== intentResponse && !!intentResponse.topScoringIntent && !!intentResponse.topScoringIntent.intent) {\n          let addedIntent = this.privAddedLmIntents[intentResponse.topScoringIntent.intent];\n          if (this.privUmbrellaIntent !== undefined) {\n            addedIntent = this.privUmbrellaIntent;\n          }\n          if (!!addedIntent) {\n            const intentId = addedIntent === undefined || addedIntent.intentName === undefined ? intentResponse.topScoringIntent.intent : addedIntent.intentName;\n            let reason = ev.result.reason;\n            if (undefined !== intentId) {\n              reason = Exports_js_2.ResultReason.RecognizedIntent;\n            }\n            // make sure, properties is set.\n            const properties = undefined !== ev.result.properties ? ev.result.properties : new Exports_js_2.PropertyCollection();\n            properties.setProperty(Exports_js_2.PropertyId.LanguageUnderstandingServiceResponse_JsonResult, connectionMessage.textBody);\n            ev = new Exports_js_2.IntentRecognitionEventArgs(new Exports_js_2.IntentRecognitionResult(intentId, ev.result.resultId, reason, ev.result.text, ev.result.duration, ev.result.offset, undefined, undefined, ev.result.errorDetails, ev.result.json, properties), ev.offset, ev.sessionId);\n          }\n        }\n        this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);\n        if (!!this.privIntentRecognizer.recognized) {\n          try {\n            this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);\n            /* eslint-disable no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        // report result to promise.\n        if (!!this.privSuccessCallback) {\n          try {\n            this.privSuccessCallback(ev.result);\n          } catch (e) {\n            if (!!this.privErrorCallback) {\n              this.privErrorCallback(e);\n            }\n          }\n          // Only invoke the call back once.\n          // and if it's successful don't invoke the\n          // error after that.\n          this.privSuccessCallback = undefined;\n          this.privErrorCallback = undefined;\n        }\n        processed = true;\n        break;\n      default:\n        break;\n    }\n    const defferal = new Exports_js_1.Deferred();\n    defferal.resolve(processed);\n    return defferal.promise;\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    const properties = new Exports_js_2.PropertyCollection();\n    properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);\n    if (!!this.privIntentRecognizer.canceled) {\n      const cancelEvent = new Exports_js_2.IntentRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, undefined, sessionId);\n      try {\n        this.privIntentRecognizer.canceled(this.privIntentRecognizer, cancelEvent);\n        /* eslint-disable no-empty */\n      } catch (_a) {}\n    }\n    if (!!this.privSuccessCallback) {\n      const result = new Exports_js_2.IntentRecognitionResult(undefined,\n      // Intent Id\n      requestId, Exports_js_2.ResultReason.Canceled, undefined,\n      // Text\n      undefined,\n      // Duration\n      undefined,\n      // Offset\n      undefined,\n      // Language\n      undefined,\n      // LanguageDetectionConfidence\n      error, undefined,\n      // Json\n      properties);\n      try {\n        this.privSuccessCallback(result);\n        this.privSuccessCallback = undefined;\n        /* eslint-disable no-empty */\n      } catch (_b) {}\n    }\n  }\n}\nexports.IntentServiceRecognizer = IntentServiceRecognizer;\n\n//# sourceMappingURL=IntentServiceRecognizer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}