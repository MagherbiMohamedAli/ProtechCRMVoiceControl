{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebsocketMessageFormatter = void 0;\nconst Exports_js_1 = require(\"../common/Exports.js\");\nconst CRLF = \"\\r\\n\";\nclass WebsocketMessageFormatter {\n  toConnectionMessage(message) {\n    const deferral = new Exports_js_1.Deferred();\n    try {\n      if (message.messageType === Exports_js_1.MessageType.Text) {\n        const textMessage = message.textContent;\n        let headers = {};\n        let body = null;\n        if (textMessage) {\n          const headerBodySplit = textMessage.split(\"\\r\\n\\r\\n\");\n          if (headerBodySplit && headerBodySplit.length > 0) {\n            headers = this.parseHeaders(headerBodySplit[0]);\n            if (headerBodySplit.length > 1) {\n              body = headerBodySplit[1];\n            }\n          }\n        }\n        deferral.resolve(new Exports_js_1.ConnectionMessage(message.messageType, body, headers, message.id));\n      } else if (message.messageType === Exports_js_1.MessageType.Binary) {\n        const binaryMessage = message.binaryContent;\n        let headers = {};\n        let body = null;\n        if (!binaryMessage || binaryMessage.byteLength < 2) {\n          throw new Error(\"Invalid binary message format. Header length missing.\");\n        }\n        const dataView = new DataView(binaryMessage);\n        const headerLength = dataView.getInt16(0);\n        if (binaryMessage.byteLength < headerLength + 2) {\n          throw new Error(\"Invalid binary message format. Header content missing.\");\n        }\n        let headersString = \"\";\n        for (let i = 0; i < headerLength; i++) {\n          headersString += String.fromCharCode(dataView.getInt8(i + 2));\n        }\n        headers = this.parseHeaders(headersString);\n        if (binaryMessage.byteLength > headerLength + 2) {\n          body = binaryMessage.slice(2 + headerLength);\n        }\n        deferral.resolve(new Exports_js_1.ConnectionMessage(message.messageType, body, headers, message.id));\n      }\n    } catch (e) {\n      deferral.reject(`Error formatting the message. Error: ${e}`);\n    }\n    return deferral.promise;\n  }\n  fromConnectionMessage(message) {\n    const deferral = new Exports_js_1.Deferred();\n    try {\n      if (message.messageType === Exports_js_1.MessageType.Text) {\n        const payload = `${this.makeHeaders(message)}${CRLF}${message.textBody ? message.textBody : \"\"}`;\n        deferral.resolve(new Exports_js_1.RawWebsocketMessage(Exports_js_1.MessageType.Text, payload, message.id));\n      } else if (message.messageType === Exports_js_1.MessageType.Binary) {\n        const headersString = this.makeHeaders(message);\n        const content = message.binaryBody;\n        const headerBuffer = this.stringToArrayBuffer(headersString);\n        const headerInt8Array = new Int8Array(headerBuffer);\n        const headerLength = headerInt8Array.byteLength;\n        const payloadInt8Array = new Int8Array(2 + headerLength + (content ? content.byteLength : 0));\n        payloadInt8Array[0] = headerLength >> 8 & 0xff;\n        payloadInt8Array[1] = headerLength & 0xff;\n        payloadInt8Array.set(headerInt8Array, 2);\n        if (content) {\n          const bodyInt8Array = new Int8Array(content);\n          payloadInt8Array.set(bodyInt8Array, 2 + headerLength);\n        }\n        const payload = payloadInt8Array.buffer;\n        deferral.resolve(new Exports_js_1.RawWebsocketMessage(Exports_js_1.MessageType.Binary, payload, message.id));\n      }\n    } catch (e) {\n      deferral.reject(`Error formatting the message. ${e}`);\n    }\n    return deferral.promise;\n  }\n  makeHeaders(message) {\n    let headersString = \"\";\n    if (message.headers) {\n      for (const header in message.headers) {\n        if (header) {\n          headersString += `${header}: ${message.headers[header]}${CRLF}`;\n        }\n      }\n    }\n    return headersString;\n  }\n  parseHeaders(headersString) {\n    const headers = {};\n    if (headersString) {\n      const headerMatches = headersString.match(/[^\\r\\n]+/g);\n      if (headers) {\n        for (const header of headerMatches) {\n          if (header) {\n            const separatorIndex = header.indexOf(\":\");\n            const headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;\n            const headerValue = separatorIndex > 0 && header.length > separatorIndex + 1 ? header.substr(separatorIndex + 1).trim() : \"\";\n            headers[headerName] = headerValue;\n          }\n        }\n      }\n    }\n    return headers;\n  }\n  stringToArrayBuffer(str) {\n    const buffer = new ArrayBuffer(str.length);\n    const view = new DataView(buffer);\n    for (let i = 0; i < str.length; i++) {\n      view.setUint8(i, str.charCodeAt(i));\n    }\n    return buffer;\n  }\n}\nexports.WebsocketMessageFormatter = WebsocketMessageFormatter;\n\n//# sourceMappingURL=WebsocketMessageFormatter.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}