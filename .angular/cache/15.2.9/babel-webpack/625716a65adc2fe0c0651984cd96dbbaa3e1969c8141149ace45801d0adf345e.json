{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PcmRecorder = void 0;\nconst Exports_1 = require(\"../common/Exports\");\nclass PcmRecorder {\n  constructor(stopInputOnRelease) {\n    this.privStopInputOnRelease = stopInputOnRelease;\n  }\n  record(context, mediaStream, outputStream) {\n    const desiredSampleRate = 16000;\n    const waveStreamEncoder = new Exports_1.RiffPcmEncoder(context.sampleRate, desiredSampleRate);\n    const micInput = context.createMediaStreamSource(mediaStream);\n    const attachScriptProcessor = () => {\n      // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n      const scriptNode = (() => {\n        let bufferSize = 0;\n        try {\n          return context.createScriptProcessor(bufferSize, 1, 1);\n        } catch (error) {\n          // Webkit (<= version 31) requires a valid bufferSize.\n          bufferSize = 2048;\n          let audioSampleRate = context.sampleRate;\n          while (bufferSize < 16384 && audioSampleRate >= 2 * desiredSampleRate) {\n            bufferSize <<= 1;\n            audioSampleRate >>= 1;\n          }\n          return context.createScriptProcessor(bufferSize, 1, 1);\n        }\n      })();\n      scriptNode.onaudioprocess = event => {\n        const inputFrame = event.inputBuffer.getChannelData(0);\n        if (outputStream && !outputStream.isClosed) {\n          const waveFrame = waveStreamEncoder.encode(inputFrame);\n          if (!!waveFrame) {\n            outputStream.writeStreamChunk({\n              buffer: waveFrame,\n              isEnd: false,\n              timeReceived: Date.now()\n            });\n          }\n        }\n      };\n      micInput.connect(scriptNode);\n      scriptNode.connect(context.destination);\n      this.privMediaResources = {\n        scriptProcessorNode: scriptNode,\n        source: micInput,\n        stream: mediaStream\n      };\n    };\n    // https://webaudio.github.io/web-audio-api/#audioworklet\n    // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\n    const skipAudioWorklet = !!this.privSpeechProcessorScript && this.privSpeechProcessorScript.toLowerCase() === \"ignore\";\n    if (!!context.audioWorklet && !skipAudioWorklet) {\n      if (!this.privSpeechProcessorScript) {\n        const workletScript = `class SP extends AudioWorkletProcessor {\n                    constructor(options) {\n                      super(options);\n                    }\n                    process(inputs, outputs) {\n                      const input = inputs[0];\n                      const output = [];\n                      for (let channel = 0; channel < input.length; channel += 1) {\n                        output[channel] = input[channel];\n                      }\n                      this.port.postMessage(output[0]);\n                      return true;\n                    }\n                  }\n                  registerProcessor('speech-processor', SP);`;\n        const blob = new Blob([workletScript], {\n          type: \"application/javascript; charset=utf-8\"\n        });\n        this.privSpeechProcessorScript = URL.createObjectURL(blob);\n      }\n      context.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {\n        const workletNode = new AudioWorkletNode(context, \"speech-processor\");\n        workletNode.port.onmessage = ev => {\n          const inputFrame = ev.data;\n          if (outputStream && !outputStream.isClosed) {\n            const waveFrame = waveStreamEncoder.encode(inputFrame);\n            if (!!waveFrame) {\n              outputStream.writeStreamChunk({\n                buffer: waveFrame,\n                isEnd: false,\n                timeReceived: Date.now()\n              });\n            }\n          }\n        };\n        micInput.connect(workletNode);\n        workletNode.connect(context.destination);\n        this.privMediaResources = {\n          scriptProcessorNode: workletNode,\n          source: micInput,\n          stream: mediaStream\n        };\n      }).catch(() => {\n        attachScriptProcessor();\n      });\n    } else {\n      try {\n        attachScriptProcessor();\n      } catch (err) {\n        throw new Error(`Unable to start audio worklet node for PCMRecorder: ${err}`);\n      }\n    }\n  }\n  releaseMediaResources(context) {\n    if (this.privMediaResources) {\n      if (this.privMediaResources.scriptProcessorNode) {\n        this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\n        this.privMediaResources.scriptProcessorNode = null;\n      }\n      if (this.privMediaResources.source) {\n        this.privMediaResources.source.disconnect();\n        if (this.privStopInputOnRelease) {\n          this.privMediaResources.stream.getTracks().forEach(track => track.stop());\n        }\n        this.privMediaResources.source = null;\n      }\n    }\n  }\n  setWorkletUrl(url) {\n    this.privSpeechProcessorScript = url;\n  }\n}\nexports.PcmRecorder = PcmRecorder;\n\n//# sourceMappingURL=PCMRecorder.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}