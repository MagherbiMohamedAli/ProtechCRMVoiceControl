{"ast":null,"code":"\"use strict\";\n\n//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connection = void 0;\nconst Exports_js_1 = require(\"../common.speech/Exports.js\");\nconst Exports_js_2 = require(\"../common/Exports.js\");\nconst ConnectionMessage_js_1 = require(\"./ConnectionMessage.js\");\nconst Contracts_js_1 = require(\"./Contracts.js\");\nconst Exports_js_3 = require(\"./Exports.js\");\n/**\n * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.\n * By default, a Recognizer autonomously manages connection to service when needed.\n * The Connection class provides additional methods for users to explicitly open or close a connection and\n * to subscribe to connection status changes.\n * The use of Connection is optional, and mainly for scenarios where fine tuning of application\n * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection\n * in advance before starting recognition on the Recognizer associated with this Connection.\n * If the Recognizer needs to connect or disconnect to service, it will\n * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection\n * status via Connected/Disconnected events.\n * Added in version 1.2.1.\n */\nclass Connection {\n  /**\n   * Gets the Connection instance from the specified recognizer.\n   * @param recognizer The recognizer associated with the connection.\n   * @return The Connection instance of the recognizer.\n   */\n  static fromRecognizer(recognizer) {\n    const recoBase = recognizer.internalData;\n    const ret = new Connection();\n    ret.privInternalData = recoBase;\n    ret.setupEvents();\n    return ret;\n  }\n  /**\n   * Gets the Connection instance from the specified synthesizer.\n   * @param synthesizer The synthesizer associated with the connection.\n   * @return The Connection instance of the synthesizer.\n   */\n  static fromSynthesizer(synthesizer) {\n    const synthBase = synthesizer.internalData;\n    const ret = new Connection();\n    ret.privInternalData = synthBase;\n    ret.setupEvents();\n    return ret;\n  }\n  /**\n   * Starts to set up connection to the service.\n   * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the\n   * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect\n   *\n   * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\n   * be notified when the connection is established.\n   */\n  openConnection(cb, err) {\n    Exports_js_2.marshalPromiseToCallbacks(this.privInternalData.connect(), cb, err);\n  }\n  /**\n   * Closes the connection the service.\n   * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.\n   *\n   * If closeConnection() is called during recognition, recognition will fail and cancel with an error.\n   */\n  closeConnection(cb, err) {\n    if (this.privInternalData instanceof Exports_js_1.SynthesisAdapterBase) {\n      throw new Error(\"Disconnecting a synthesizer's connection is currently not supported\");\n    } else {\n      Exports_js_2.marshalPromiseToCallbacks(this.privInternalData.disconnect(), cb, err);\n    }\n  }\n  /**\n   * Appends a parameter in a message to service.\n   * Added in version 1.12.1.\n   * @param path The path of the network message.\n   * @param propertyName Name of the property\n   * @param propertyValue Value of the property. This is a json string.\n   */\n  setMessageProperty(path, propertyName, propertyValue) {\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(propertyName, \"propertyName\");\n    if (this.privInternalData instanceof Exports_js_1.ServiceRecognizerBase) {\n      if (path.toLowerCase() !== \"speech.context\") {\n        throw new Error(\"Only speech.context message property sets are currently supported for recognizer\");\n      } else {\n        this.privInternalData.speechContext.setSection(propertyName, propertyValue);\n      }\n    } else if (this.privInternalData instanceof Exports_js_1.SynthesisAdapterBase) {\n      if (path.toLowerCase() !== \"synthesis.context\") {\n        throw new Error(\"Only synthesis.context message property sets are currently supported for synthesizer\");\n      } else {\n        this.privInternalData.synthesisContext.setSection(propertyName, propertyValue);\n      }\n    }\n  }\n  /**\n   * Sends a message to the speech service.\n   * Added in version 1.13.0.\n   * @param path The WebSocket path of the message\n   * @param payload The payload of the message. This is a json string or a ArrayBuffer.\n   * @param success A callback to indicate success.\n   * @param error A callback to indicate an error.\n   */\n  sendMessageAsync(path, payload, success, error) {\n    Exports_js_2.marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(path, payload), success, error);\n  }\n  /**\n   * Dispose of associated resources.\n   */\n  close() {\n    /* eslint-disable no-empty */\n  }\n  setupEvents() {\n    this.privEventListener = this.privInternalData.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\n        if (!!this.connected) {\n          this.connected(new Exports_js_3.ConnectionEventArgs(connectionEvent.connectionId));\n        }\n      } else if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        if (!!this.disconnected) {\n          this.disconnected(new Exports_js_3.ConnectionEventArgs(connectionEvent.connectionId));\n        }\n      } else if (connectionEvent.name === \"ConnectionMessageSentEvent\") {\n        if (!!this.messageSent) {\n          this.messageSent(new Exports_js_3.ConnectionMessageEventArgs(new ConnectionMessage_js_1.ConnectionMessageImpl(connectionEvent.message)));\n        }\n      } else if (connectionEvent.name === \"ConnectionMessageReceivedEvent\") {\n        if (!!this.messageReceived) {\n          this.messageReceived(new Exports_js_3.ConnectionMessageEventArgs(new ConnectionMessage_js_1.ConnectionMessageImpl(connectionEvent.message)));\n        }\n      }\n    });\n    this.privServiceEventListener = this.privInternalData.serviceEvents.attach(e => {\n      if (!!this.receivedServiceMessage) {\n        this.receivedServiceMessage(new Exports_js_3.ServiceEventArgs(e.jsonString, e.name));\n      }\n    });\n  }\n}\nexports.Connection = Connection;\n\n//# sourceMappingURL=Connection.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}