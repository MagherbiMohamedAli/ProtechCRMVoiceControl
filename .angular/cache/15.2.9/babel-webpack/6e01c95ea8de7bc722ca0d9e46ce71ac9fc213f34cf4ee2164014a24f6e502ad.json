{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConversationServiceRecognizer = void 0;\nconst Exports_js_1 = require(\"../sdk/Exports.js\");\nconst Exports_js_2 = require(\"./Exports.js\");\nclass ConversationServiceRecognizer extends Exports_js_2.ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\n    this.handleSpeechPhraseMessage = textBody => __awaiter(this, void 0, void 0, function* () {\n      return this.handleSpeechPhrase(textBody);\n    });\n    this.handleSpeechHypothesisMessage = textBody => this.handleSpeechHypothesis(textBody);\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    void connectionMessage;\n    return;\n  }\n  handleRecognizedCallback(result, offset, sessionId) {\n    void result;\n    void offset;\n    void sessionId;\n    return;\n  }\n  handleRecognizingCallback(result, duration, sessionId) {\n    void result;\n    void duration;\n    void sessionId;\n    return;\n  }\n  processSpeechMessages(connectionMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let processed = false;\n      switch (connectionMessage.path.toLowerCase()) {\n        case \"speech.hypothesis\":\n        case \"speech.fragment\":\n          if (!!this.handleSpeechHypothesisMessage) {\n            this.handleSpeechHypothesisMessage(connectionMessage.textBody);\n          }\n          processed = true;\n          break;\n        case \"speech.phrase\":\n          if (!!this.handleSpeechPhraseMessage) {\n            yield this.handleSpeechPhraseMessage(connectionMessage.textBody);\n          }\n          processed = true;\n          break;\n        default:\n          break;\n      }\n      return processed;\n    });\n  }\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    // Implementing to allow inheritance\n    void sessionId;\n    void requestId;\n    void cancellationReason;\n    void errorCode;\n    void error;\n  }\n  handleSpeechPhrase(textBody) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const simple = Exports_js_2.SimpleSpeechPhrase.fromJSON(textBody);\n      const resultReason = Exports_js_2.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);\n      let result;\n      const resultProps = new Exports_js_1.PropertyCollection();\n      resultProps.setProperty(Exports_js_1.PropertyId.SpeechServiceResponse_JsonResult, textBody);\n      const simpleOffset = simple.Offset + this.privRequestSession.currentTurnAudioOffset;\n      let offset = simpleOffset;\n      this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);\n      if (Exports_js_1.ResultReason.Canceled === resultReason) {\n        const cancelReason = Exports_js_2.EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);\n        const cancellationErrorCode = Exports_js_2.EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);\n        yield this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_js_2.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));\n      } else {\n        if (!(this.privRequestSession.isSpeechEnded && resultReason === Exports_js_1.ResultReason.NoMatch && simple.RecognitionStatus !== Exports_js_2.RecognitionStatus.InitialSilenceTimeout)) {\n          if (this.privRecognizerConfig.parameters.getProperty(Exports_js_2.OutputFormatPropertyName) === Exports_js_1.OutputFormat[Exports_js_1.OutputFormat.Simple]) {\n            result = new Exports_js_1.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simpleOffset, simple.Language, simple.LanguageDetectionConfidence, simple.SpeakerId, undefined, textBody, resultProps);\n          } else {\n            const detailed = Exports_js_2.DetailedSpeechPhrase.fromJSON(textBody);\n            const totalOffset = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;\n            const offsetCorrectedJson = detailed.getJsonWithCorrectedOffsets(totalOffset);\n            result = new Exports_js_1.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, detailed.Text, detailed.Duration, totalOffset, detailed.Language, detailed.LanguageDetectionConfidence, detailed.SpeakerId, undefined, offsetCorrectedJson, resultProps);\n            offset = result.offset;\n          }\n          this.handleRecognizedCallback(result, offset, this.privRequestSession.sessionId);\n        }\n      }\n    });\n  }\n  handleSpeechHypothesis(textBody) {\n    const hypothesis = Exports_js_2.SpeechHypothesis.fromJSON(textBody);\n    const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n    const resultProps = new Exports_js_1.PropertyCollection();\n    resultProps.setProperty(Exports_js_1.PropertyId.SpeechServiceResponse_JsonResult, textBody);\n    const result = new Exports_js_1.SpeechRecognitionResult(this.privRequestSession.requestId, Exports_js_1.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, hypothesis.SpeakerId, undefined, textBody, resultProps);\n    this.privRequestSession.onHypothesis(offset);\n    this.handleRecognizingCallback(result, hypothesis.Duration, this.privRequestSession.sessionId);\n  }\n}\nexports.ConversationServiceRecognizer = ConversationServiceRecognizer;\n\n//# sourceMappingURL=ConversationServiceRecognizer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}