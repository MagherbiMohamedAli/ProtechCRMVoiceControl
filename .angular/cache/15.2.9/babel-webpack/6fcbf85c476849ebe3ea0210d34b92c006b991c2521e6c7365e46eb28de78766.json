{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TranslationRecognizer = void 0;\nconst Exports_js_1 = require(\"../common.speech/Exports.js\");\nconst Exports_js_2 = require(\"../common/Exports.js\");\nconst Connection_js_1 = require(\"./Connection.js\");\nconst Contracts_js_1 = require(\"./Contracts.js\");\nconst Exports_js_3 = require(\"./Exports.js\");\n/**\n * Translation recognizer\n * @class TranslationRecognizer\n */\nclass TranslationRecognizer extends Exports_js_3.Recognizer {\n  /**\n   * Initializes an instance of the TranslationRecognizer.\n   * @constructor\n   * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.\n   * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer\n   * @param {IConnectionFactory} connectionFactory - An optional connection factory to use to generate the endpoint URIs, headers to set, etc...\n   */\n  constructor(speechConfig, audioConfig, connectionFactory) {\n    const configImpl = speechConfig;\n    Contracts_js_1.Contracts.throwIfNull(configImpl, \"speechConfig\");\n    super(audioConfig, configImpl.properties, connectionFactory || new Exports_js_1.TranslationConnectionFactory());\n    this.privDisposedTranslationRecognizer = false;\n    if (this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice, undefined) !== undefined) {\n      Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice]);\n    }\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages]);\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);\n  }\n  /**\n   * TranslationRecognizer constructor.\n   * @constructor\n   * @param {SpeechTranslationConfig} speechTranslationConfig - an set of initial properties for this recognizer\n   * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer\n   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer\n   */\n  static FromConfig(speechTranslationConfig, autoDetectSourceLanguageConfig, audioConfig) {\n    const speechTranslationConfigImpl = speechTranslationConfig;\n    autoDetectSourceLanguageConfig.properties.mergeTo(speechTranslationConfigImpl.properties);\n    return new TranslationRecognizer(speechTranslationConfig, audioConfig);\n  }\n  /**\n   * Gets the language name that was set when the recognizer was created.\n   * @member TranslationRecognizer.prototype.speechRecognitionLanguage\n   * @function\n   * @public\n   * @returns {string} Gets the language name that was set when the recognizer was created.\n   */\n  get speechRecognitionLanguage() {\n    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage);\n  }\n  /**\n   * Gets target languages for translation that were set when the recognizer was created.\n   * The language is specified in BCP-47 format. The translation will provide translated text for each of language.\n   * @member TranslationRecognizer.prototype.targetLanguages\n   * @function\n   * @public\n   * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.\n   */\n  get targetLanguages() {\n    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(\",\");\n  }\n  /**\n   * Gets the name of output voice.\n   * @member TranslationRecognizer.prototype.voiceName\n   * @function\n   * @public\n   * @returns {string} the name of output voice.\n   */\n  get voiceName() {\n    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice, undefined);\n  }\n  /**\n   * The collection of properties and their values defined for this TranslationRecognizer.\n   * @member TranslationRecognizer.prototype.properties\n   * @function\n   * @public\n   * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.\n   */\n  get properties() {\n    return this.privProperties;\n  }\n  /**\n   * Gets the authorization token used to communicate with the service.\n   * @member TranslationRecognizer.prototype.authorizationToken\n   * @function\n   * @public\n   * @returns {string} Authorization token.\n   */\n  get authorizationToken() {\n    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);\n  }\n  /**\n   * Gets/Sets the authorization token used to communicate with the service.\n   * @member TranslationRecognizer.prototype.authorizationToken\n   * @function\n   * @public\n   * @param {string} value - Authorization token.\n   */\n  set authorizationToken(value) {\n    this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, value);\n  }\n  /**\n   * Starts recognition and translation, and stops after the first utterance is recognized.\n   * The task returns the translation text as result.\n   * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitable only\n   * for single shot recognition like command or query. For long-running recognition,\n   * use startContinuousRecognitionAsync() instead.\n   * @member TranslationRecognizer.prototype.recognizeOnceAsync\n   * @function\n   * @public\n   * @param cb - Callback that received the result when the translation has completed.\n   * @param err - Callback invoked in case of an error.\n   */\n  recognizeOnceAsync(cb, err) {\n    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n    Exports_js_2.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(Exports_js_1.RecognitionMode.Interactive), cb, err);\n  }\n  /**\n   * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.\n   * User must subscribe to events to receive translation results.\n   * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync\n   * @function\n   * @public\n   * @param cb - Callback that received the translation has started.\n   * @param err - Callback invoked in case of an error.\n   */\n  startContinuousRecognitionAsync(cb, err) {\n    Exports_js_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_1.RecognitionMode.Conversation), cb, err);\n  }\n  /**\n   * Stops continuous recognition and translation.\n   * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync\n   * @function\n   * @public\n   * @param cb - Callback that received the translation has stopped.\n   * @param err - Callback invoked in case of an error.\n   */\n  stopContinuousRecognitionAsync(cb, err) {\n    Exports_js_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);\n  }\n  /**\n   * dynamically remove a language from list of target language\n   * (can be used while recognition is ongoing)\n   * @member TranslationRecognizer.prototype.removeTargetLanguage\n   * @function\n   * @param lang - language to be removed\n   * @public\n   */\n  removeTargetLanguage(lang) {\n    Contracts_js_1.Contracts.throwIfNullOrUndefined(lang, \"language to be removed\");\n    if (this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {\n      const languages = this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(\",\");\n      const index = languages.indexOf(lang);\n      if (index > -1) {\n        languages.splice(index, 1);\n        this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(\",\"));\n        this.updateLanguages(languages);\n      }\n    }\n  }\n  /**\n   * dynamically add a language to list of target language\n   * (can be used while recognition is ongoing)\n   * @member TranslationRecognizer.prototype.addTargetLanguage\n   * @function\n   * @param lang - language to be added\n   * @public\n   */\n  addTargetLanguage(lang) {\n    Contracts_js_1.Contracts.throwIfNullOrUndefined(lang, \"language to be added\");\n    let languages = [];\n    if (this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {\n      languages = this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(\",\");\n      if (!languages.includes(lang)) {\n        languages.push(lang);\n        this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(\",\"));\n      }\n    } else {\n      this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, lang);\n      languages = [lang];\n    }\n    this.updateLanguages(languages);\n  }\n  /**\n   * closes all external resources held by an instance of this class.\n   * @member TranslationRecognizer.prototype.close\n   * @function\n   * @public\n   */\n  close(cb, errorCb) {\n    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);\n    Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);\n  }\n  /**\n   * handles ConnectionEstablishedEvent for conversation translation scenarios.\n   * @member TranslationRecognizer.prototype.onConnection\n   * @function\n   * @public\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  onConnection() {}\n  dispose(disposing) {\n    const _super = Object.create(null, {\n      dispose: {\n        get: () => super.dispose\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privDisposedTranslationRecognizer) {\n        return;\n      }\n      this.privDisposedTranslationRecognizer = true;\n      if (disposing) {\n        yield this.implRecognizerStop();\n        yield _super.dispose.call(this, disposing);\n      }\n    });\n  }\n  createRecognizerConfig(speechConfig) {\n    return new Exports_js_1.RecognizerConfig(speechConfig, this.privProperties);\n  }\n  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {\n    const configImpl = audioConfig;\n    return new Exports_js_1.TranslationServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);\n  }\n  updateLanguages(languages) {\n    const conn = Connection_js_1.Connection.fromRecognizer(this);\n    if (!!conn) {\n      conn.setMessageProperty(\"speech.context\", \"translationcontext\", {\n        to: languages\n      });\n      conn.sendMessageAsync(\"event\", JSON.stringify({\n        id: \"translation\",\n        name: \"updateLanguage\",\n        to: languages\n      }));\n    }\n  }\n}\nexports.TranslationRecognizer = TranslationRecognizer;\n\n//# sourceMappingURL=TranslationRecognizer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}