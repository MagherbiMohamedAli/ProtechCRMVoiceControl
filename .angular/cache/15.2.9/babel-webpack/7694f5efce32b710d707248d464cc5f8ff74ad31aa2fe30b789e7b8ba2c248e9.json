{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReplayableAudioNode = void 0;\nclass ReplayableAudioNode {\n  constructor(audioSource, bytesPerSecond) {\n    this.privBuffers = [];\n    this.privReplayOffset = 0;\n    this.privLastShrinkOffset = 0;\n    this.privBufferStartOffset = 0;\n    this.privBufferSerial = 0;\n    this.privBufferedBytes = 0;\n    this.privReplay = false;\n    this.privLastChunkAcquiredTime = 0;\n    this.privAudioNode = audioSource;\n    this.privBytesPerSecond = bytesPerSecond;\n  }\n  id() {\n    return this.privAudioNode.id();\n  }\n  // Reads and returns the next chunk of audio buffer.\n  // If replay of existing buffers are needed, read() will first seek and replay\n  // existing content, and upoin completion it will read new content from the underlying\n  // audio node, saving that content into the replayable buffers.\n  read() {\n    // if there is a replay request to honor.\n    if (!!this.privReplay && this.privBuffers.length !== 0) {\n      // Find the start point in the buffers.\n      // Offsets are in 100ns increments.\n      // So how many bytes do we need to seek to get the right offset?\n      const offsetToSeek = this.privReplayOffset - this.privBufferStartOffset;\n      let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\n      if (0 !== bytesToSeek % 2) {\n        bytesToSeek++;\n      }\n      let i = 0;\n      while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\n        bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\n      }\n      if (i < this.privBuffers.length) {\n        const retVal = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);\n        this.privReplayOffset += retVal.byteLength / this.privBytesPerSecond * 1e+7;\n        // If we've reached the end of the buffers, stop replaying.\n        if (i === this.privBuffers.length - 1) {\n          this.privReplay = false;\n        }\n        return Promise.resolve({\n          buffer: retVal,\n          isEnd: false,\n          timeReceived: this.privBuffers[i].chunk.timeReceived\n        });\n      }\n    }\n    return this.privAudioNode.read().then(result => {\n      if (result && result.buffer) {\n        this.privBuffers.push(new BufferEntry(result, this.privBufferSerial++, this.privBufferedBytes));\n        this.privBufferedBytes += result.buffer.byteLength;\n      }\n      return result;\n    });\n  }\n  detach() {\n    this.privBuffers = undefined;\n    return this.privAudioNode.detach();\n  }\n  replay() {\n    if (this.privBuffers && 0 !== this.privBuffers.length) {\n      this.privReplay = true;\n      this.privReplayOffset = this.privLastShrinkOffset;\n    }\n  }\n  // Shrinks the existing audio buffers to start at the new offset, or at the\n  // beginning of the buffer closest to the requested offset.\n  // A replay request will start from the last shrink point.\n  shrinkBuffers(offset) {\n    if (this.privBuffers === undefined || this.privBuffers.length === 0) {\n      return;\n    }\n    this.privLastShrinkOffset = offset;\n    // Find the start point in the buffers.\n    // Offsets are in 100ns increments.\n    // So how many bytes do we need to seek to get the right offset?\n    const offsetToSeek = offset - this.privBufferStartOffset;\n    let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\n    let i = 0;\n    while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\n      bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\n    }\n    this.privBufferStartOffset = Math.round(offset - bytesToSeek / this.privBytesPerSecond * 1e+7);\n    this.privBuffers = this.privBuffers.slice(i);\n  }\n  // Finds the time a buffer of audio was first seen by offset.\n  findTimeAtOffset(offset) {\n    if (offset < this.privBufferStartOffset || this.privBuffers === undefined) {\n      return 0;\n    }\n    for (const value of this.privBuffers) {\n      const startOffset = value.byteOffset / this.privBytesPerSecond * 1e7;\n      const endOffset = startOffset + value.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;\n      if (offset >= startOffset && offset <= endOffset) {\n        return value.chunk.timeReceived;\n      }\n    }\n    return 0;\n  }\n}\nexports.ReplayableAudioNode = ReplayableAudioNode;\n// Primary use of this class is to help debugging problems with the replay\n// code. If the memory cost of alloc / dealloc gets too much, drop it and just use\n// the ArrayBuffer directly.\nclass BufferEntry {\n  constructor(chunk, serial, byteOffset) {\n    this.chunk = chunk;\n    this.serial = serial;\n    this.byteOffset = byteOffset;\n  }\n}\n\n//# sourceMappingURL=ReplayableAudioNode.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}