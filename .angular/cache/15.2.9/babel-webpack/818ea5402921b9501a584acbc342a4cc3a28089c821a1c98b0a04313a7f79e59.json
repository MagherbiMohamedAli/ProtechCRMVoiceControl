{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SpeakerServiceRecognizer = void 0;\nconst Exports_js_1 = require(\"../common.browser/Exports.js\");\nconst Exports_js_2 = require(\"../common/Exports.js\");\nconst Exports_js_3 = require(\"../sdk/Exports.js\");\nconst Exports_js_4 = require(\"./Exports.js\");\nconst SpeechConnectionMessage_Internal_js_1 = require(\"./SpeechConnectionMessage.Internal.js\");\n// eslint-disable-next-line max-classes-per-file\nclass SpeakerServiceRecognizer extends Exports_js_4.ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\n    this.privSpeakerRecognizer = recognizer;\n    this.privSpeakerAudioSource = audioSource;\n    this.recognizeSpeaker = model => this.recognizeSpeakerOnce(model);\n    this.sendPrePayloadJSONOverride = () => this.noOp();\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    let processed = false;\n    const resultProps = new Exports_js_3.PropertyCollection();\n    if (connectionMessage.messageType === Exports_js_2.MessageType.Text) {\n      resultProps.setProperty(Exports_js_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n    }\n    switch (connectionMessage.path.toLowerCase()) {\n      case \"speaker.response\":\n        const response = JSON.parse(connectionMessage.textBody);\n        let result;\n        if (response.status.statusCode.toLowerCase() !== \"success\") {\n          result = new Exports_js_3.SpeakerRecognitionResult(response, Exports_js_3.ResultReason.Canceled, Exports_js_3.CancellationErrorCode.ServiceError, response.status.reason);\n        } else {\n          result = new Exports_js_3.SpeakerRecognitionResult(response, Exports_js_3.ResultReason.RecognizedSpeaker);\n        }\n        if (!!this.privResultDeferral) {\n          this.privResultDeferral.resolve(result);\n        }\n        processed = true;\n        break;\n      default:\n        break;\n    }\n    const defferal = new Exports_js_2.Deferred();\n    defferal.resolve(processed);\n    return defferal.promise;\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    const properties = new Exports_js_3.PropertyCollection();\n    properties.setProperty(Exports_js_4.CancellationErrorCodePropertyName, Exports_js_3.CancellationErrorCode[errorCode]);\n    if (!!this.privResultDeferral) {\n      const result = new Exports_js_3.SpeakerRecognitionResult({\n        scenario: this.privSpeakerModel.scenario,\n        status: {\n          statusCode: error,\n          reason: error\n        }\n      }, Exports_js_3.ResultReason.Canceled, errorCode, error);\n      try {\n        this.privResultDeferral.resolve(result);\n      } catch (error) {\n        this.privResultDeferral.reject(error);\n      }\n    }\n  }\n  recognizeSpeakerOnce(model) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privSpeakerModel = model;\n      this.voiceProfileType = model.scenario;\n      if (!this.privResultDeferral) {\n        this.privResultDeferral = new Exports_js_2.Deferred();\n      }\n      this.privRequestSession.startNewRecognition();\n      this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events);\n      this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\n      // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n      const conPromise = this.connectImpl();\n      const preAudioPromise = this.sendPreAudioMessages(this.extractSpeakerContext(model));\n      const node = yield this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId);\n      const format = yield this.privSpeakerAudioSource.format;\n      const deviceInfo = yield this.privSpeakerAudioSource.deviceInfo;\n      const audioNode = new Exports_js_1.ReplayableAudioNode(node, format.avgBytesPerSec);\n      yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n      this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {\n        source: deviceInfo\n      };\n      try {\n        yield conPromise;\n        yield preAudioPromise;\n      } catch (err) {\n        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.ConnectionFailure, err);\n      }\n      const sessionStartEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);\n      if (!!this.privRecognizer.sessionStarted) {\n        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n      }\n      void this.receiveMessage();\n      const audioSendPromise = this.sendAudio(audioNode);\n      // /* eslint-disable no-empty */\n      audioSendPromise.then(() => {}, error => {\n        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);\n      });\n      return this.privResultDeferral.promise;\n    });\n  }\n  sendPreAudioMessages(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      yield this.sendSpeakerRecognition(connection, context);\n      // await this.sendWaveHeader(connection);\n    });\n  }\n\n  sendSpeakerRecognition(connection, context) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const speakerContextJson = JSON.stringify(context);\n      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, \"speaker.context\", this.privRequestSession.requestId, \"application/json; charset=utf-8\", speakerContextJson));\n    });\n  }\n  extractSpeakerContext(model) {\n    return {\n      features: {\n        interimResult: \"enabled\",\n        progressiveDetection: \"disabled\"\n      },\n      profileIds: model.profileIds,\n      scenario: model.scenario\n    };\n  }\n}\nexports.SpeakerServiceRecognizer = SpeakerServiceRecognizer;\n\n//# sourceMappingURL=SpeakerServiceRecognizer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}