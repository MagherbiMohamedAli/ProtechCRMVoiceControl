{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChunkedArrayBufferStream = void 0;\nconst Exports_js_1 = require(\"./Exports.js\");\nclass ChunkedArrayBufferStream extends Exports_js_1.Stream {\n  constructor(targetChunkSize, streamId) {\n    super(streamId);\n    this.privTargetChunkSize = targetChunkSize;\n    this.privNextBufferReadyBytes = 0;\n  }\n  writeStreamChunk(chunk) {\n    // No pending write, and the buffer is the right size so write it.\n    if (chunk.isEnd || 0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize) {\n      super.writeStreamChunk(chunk);\n      return;\n    }\n    let bytesCopiedFromBuffer = 0;\n    while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {\n      // Fill the next buffer.\n      if (undefined === this.privNextBufferToWrite) {\n        this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);\n        this.privNextBufferStartTime = chunk.timeReceived;\n      }\n      // Find out how many bytes we can copy into the read buffer.\n      const bytesToCopy = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);\n      const targetView = new Uint8Array(this.privNextBufferToWrite);\n      const sourceView = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));\n      targetView.set(sourceView, this.privNextBufferReadyBytes);\n      this.privNextBufferReadyBytes += bytesToCopy;\n      bytesCopiedFromBuffer += bytesToCopy;\n      // Are we ready to write?\n      if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {\n        super.writeStreamChunk({\n          buffer: this.privNextBufferToWrite,\n          isEnd: false,\n          timeReceived: this.privNextBufferStartTime\n        });\n        this.privNextBufferReadyBytes = 0;\n        this.privNextBufferToWrite = undefined;\n      }\n    }\n  }\n  close() {\n    // Send whatever is pending, then close the base class.\n    if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {\n      super.writeStreamChunk({\n        buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),\n        isEnd: false,\n        timeReceived: this.privNextBufferStartTime\n      });\n    }\n    super.close();\n  }\n}\nexports.ChunkedArrayBufferStream = ChunkedArrayBufferStream;\n\n//# sourceMappingURL=ChunkedArrayBufferStream.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}