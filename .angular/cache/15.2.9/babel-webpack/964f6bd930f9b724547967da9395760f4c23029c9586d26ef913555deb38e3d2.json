{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebsocketMessageAdapter = void 0;\nconst net = __importStar(require(\"net\"));\nconst tls = __importStar(require(\"tls\"));\nconst agent_base_1 = __importDefault(require(\"agent-base\"));\nconst https_proxy_agent_1 = __importDefault(require(\"https-proxy-agent\"));\nconst ws_1 = __importDefault(require(\"ws\"));\nconst HeaderNames_js_1 = require(\"../common.speech/HeaderNames.js\");\nconst Exports_js_1 = require(\"../common/Exports.js\");\nclass WebsocketMessageAdapter {\n  constructor(uri, connectionId, messageFormatter, proxyInfo, headers, enableCompression) {\n    if (!uri) {\n      throw new Exports_js_1.ArgumentNullError(\"uri\");\n    }\n    if (!messageFormatter) {\n      throw new Exports_js_1.ArgumentNullError(\"messageFormatter\");\n    }\n    this.proxyInfo = proxyInfo;\n    this.privConnectionEvents = new Exports_js_1.EventSource();\n    this.privConnectionId = connectionId;\n    this.privMessageFormatter = messageFormatter;\n    this.privConnectionState = Exports_js_1.ConnectionState.None;\n    this.privUri = uri;\n    this.privHeaders = headers;\n    this.privEnableCompression = enableCompression;\n    // Add the connection ID to the headers\n    this.privHeaders[HeaderNames_js_1.HeaderNames.ConnectionId] = this.privConnectionId;\n    this.privLastErrorReceived = \"\";\n  }\n  get state() {\n    return this.privConnectionState;\n  }\n  open() {\n    if (this.privConnectionState === Exports_js_1.ConnectionState.Disconnected) {\n      return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);\n    }\n    if (this.privConnectionEstablishDeferral) {\n      return this.privConnectionEstablishDeferral.promise;\n    }\n    this.privConnectionEstablishDeferral = new Exports_js_1.Deferred();\n    this.privCertificateValidatedDeferral = new Exports_js_1.Deferred();\n    this.privConnectionState = Exports_js_1.ConnectionState.Connecting;\n    try {\n      if (typeof WebSocket !== \"undefined\" && !WebsocketMessageAdapter.forceNpmWebSocket) {\n        // Browser handles cert checks.\n        this.privCertificateValidatedDeferral.resolve();\n        this.privWebsocketClient = new WebSocket(this.privUri);\n      } else {\n        const options = {\n          headers: this.privHeaders,\n          perMessageDeflate: this.privEnableCompression\n        };\n        // The ocsp library will handle validation for us and fail the connection if needed.\n        this.privCertificateValidatedDeferral.resolve();\n        options.agent = this.getAgent();\n        // Workaround for https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/465\n        // Which is root caused by https://github.com/TooTallNate/node-agent-base/issues/61\n        const uri = new URL(this.privUri);\n        let protocol = uri.protocol;\n        if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === \"wss:\") {\n          protocol = \"https:\";\n        } else if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === \"ws:\") {\n          protocol = \"http:\";\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        options.agent.protocol = protocol;\n        this.privWebsocketClient = new ws_1.default(this.privUri, options);\n      }\n      this.privWebsocketClient.binaryType = \"arraybuffer\";\n      this.privReceivingMessageQueue = new Exports_js_1.Queue();\n      this.privDisconnectDeferral = new Exports_js_1.Deferred();\n      this.privSendMessageQueue = new Exports_js_1.Queue();\n      this.processSendQueue().catch(reason => {\n        Exports_js_1.Events.instance.onEvent(new Exports_js_1.BackgroundEvent(reason));\n      });\n    } catch (error) {\n      this.privConnectionEstablishDeferral.resolve(new Exports_js_1.ConnectionOpenResponse(500, error));\n      return this.privConnectionEstablishDeferral.promise;\n    }\n    this.onEvent(new Exports_js_1.ConnectionStartEvent(this.privConnectionId, this.privUri));\n    this.privWebsocketClient.onopen = () => {\n      this.privCertificateValidatedDeferral.promise.then(() => {\n        this.privConnectionState = Exports_js_1.ConnectionState.Connected;\n        this.onEvent(new Exports_js_1.ConnectionEstablishedEvent(this.privConnectionId));\n        this.privConnectionEstablishDeferral.resolve(new Exports_js_1.ConnectionOpenResponse(200, \"\"));\n      }, error => {\n        this.privConnectionEstablishDeferral.reject(error);\n      });\n    };\n    this.privWebsocketClient.onerror = e => {\n      this.onEvent(new Exports_js_1.ConnectionErrorEvent(this.privConnectionId, e.message, e.type));\n      this.privLastErrorReceived = e.message;\n    };\n    this.privWebsocketClient.onclose = e => {\n      if (this.privConnectionState === Exports_js_1.ConnectionState.Connecting) {\n        this.privConnectionState = Exports_js_1.ConnectionState.Disconnected;\n        // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));\n        this.privConnectionEstablishDeferral.resolve(new Exports_js_1.ConnectionOpenResponse(e.code, e.reason + \" \" + this.privLastErrorReceived));\n      } else {\n        this.privConnectionState = Exports_js_1.ConnectionState.Disconnected;\n        this.privWebsocketClient = null;\n        this.onEvent(new Exports_js_1.ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));\n      }\n      this.onClose(e.code, e.reason).catch(reason => {\n        Exports_js_1.Events.instance.onEvent(new Exports_js_1.BackgroundEvent(reason));\n      });\n    };\n    this.privWebsocketClient.onmessage = e => {\n      const networkReceivedTime = new Date().toISOString();\n      if (this.privConnectionState === Exports_js_1.ConnectionState.Connected) {\n        const deferred = new Exports_js_1.Deferred();\n        // let id = ++this.idCounter;\n        this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise);\n        if (e.data instanceof ArrayBuffer) {\n          const rawMessage = new Exports_js_1.RawWebsocketMessage(Exports_js_1.MessageType.Binary, e.data);\n          this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {\n            this.onEvent(new Exports_js_1.ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n            deferred.resolve(connectionMessage);\n          }, error => {\n            // TODO: Events for these ?\n            deferred.reject(`Invalid binary message format. Error: ${error}`);\n          });\n        } else {\n          const rawMessage = new Exports_js_1.RawWebsocketMessage(Exports_js_1.MessageType.Text, e.data);\n          this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {\n            this.onEvent(new Exports_js_1.ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n            deferred.resolve(connectionMessage);\n          }, error => {\n            // TODO: Events for these ?\n            deferred.reject(`Invalid text message format. Error: ${error}`);\n          });\n        }\n      }\n    };\n    return this.privConnectionEstablishDeferral.promise;\n  }\n  send(message) {\n    if (this.privConnectionState !== Exports_js_1.ConnectionState.Connected) {\n      return Promise.reject(`Cannot send on connection that is in ${Exports_js_1.ConnectionState[this.privConnectionState]} state`);\n    }\n    const messageSendStatusDeferral = new Exports_js_1.Deferred();\n    const messageSendDeferral = new Exports_js_1.Deferred();\n    this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);\n    this.privMessageFormatter.fromConnectionMessage(message).then(rawMessage => {\n      messageSendDeferral.resolve({\n        Message: message,\n        RawWebsocketMessage: rawMessage,\n        sendStatusDeferral: messageSendStatusDeferral\n      });\n    }, error => {\n      messageSendDeferral.reject(`Error formatting the message. ${error}`);\n    });\n    return messageSendStatusDeferral.promise;\n  }\n  read() {\n    if (this.privConnectionState !== Exports_js_1.ConnectionState.Connected) {\n      return Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`);\n    }\n    return this.privReceivingMessageQueue.dequeue();\n  }\n  close(reason) {\n    if (this.privWebsocketClient) {\n      if (this.privConnectionState !== Exports_js_1.ConnectionState.Disconnected) {\n        this.privWebsocketClient.close(1000, reason ? reason : \"Normal closure by client\");\n      }\n    } else {\n      return Promise.resolve();\n    }\n    return this.privDisconnectDeferral.promise;\n  }\n  get events() {\n    return this.privConnectionEvents;\n  }\n  sendRawMessage(sendItem) {\n    try {\n      // indicates we are draining the queue and it came with no message;\n      if (!sendItem) {\n        return Promise.resolve();\n      }\n      this.onEvent(new Exports_js_1.ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message));\n      // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing\n      if (this.isWebsocketOpen) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);\n      } else {\n        return Promise.reject(\"websocket send error: Websocket not ready \" + this.privConnectionId + \" \" + sendItem.Message.id + \" \" + new Error().stack);\n      }\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(`websocket send error: ${e}`);\n    }\n  }\n  onClose(code, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const closeReason = `Connection closed. ${code}: ${reason}`;\n      this.privConnectionState = Exports_js_1.ConnectionState.Disconnected;\n      this.privDisconnectDeferral.resolve();\n      yield this.privReceivingMessageQueue.drainAndDispose(() => {\n        // TODO: Events for these ?\n        // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));\n      }, closeReason);\n      yield this.privSendMessageQueue.drainAndDispose(pendingSendItem => {\n        pendingSendItem.sendStatusDeferral.reject(closeReason);\n      }, closeReason);\n    });\n  }\n  processSendQueue() {\n    return __awaiter(this, void 0, void 0, function* () {\n      while (true) {\n        const itemToSend = this.privSendMessageQueue.dequeue();\n        const sendItem = yield itemToSend;\n        // indicates we are draining the queue and it came with no message;\n        if (!sendItem) {\n          return;\n        }\n        try {\n          yield this.sendRawMessage(sendItem);\n          sendItem.sendStatusDeferral.resolve();\n        } catch (sendError) {\n          sendItem.sendStatusDeferral.reject(sendError);\n        }\n      }\n    });\n  }\n  onEvent(event) {\n    this.privConnectionEvents.onEvent(event);\n    Exports_js_1.Events.instance.onEvent(event);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getAgent() {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const agent = new agent_base_1.default.Agent(this.createConnection);\n    if (this.proxyInfo !== undefined && this.proxyInfo.HostName !== undefined && this.proxyInfo.Port > 0) {\n      agent.proxyInfo = this.proxyInfo;\n    }\n    return agent;\n  }\n  static GetProxyAgent(proxyInfo) {\n    const httpProxyOptions = {\n      host: proxyInfo.HostName,\n      port: proxyInfo.Port\n    };\n    if (!!proxyInfo.UserName) {\n      httpProxyOptions.headers = {\n        \"Proxy-Authentication\": \"Basic \" + new Buffer(`${proxyInfo.UserName}:${proxyInfo.Password === undefined ? \"\" : proxyInfo.Password}`).toString(\"base64\")\n      };\n    } else {\n      httpProxyOptions.headers = {};\n    }\n    httpProxyOptions.headers.requestOCSP = \"true\";\n    const httpProxyAgent = new https_proxy_agent_1.default(httpProxyOptions);\n    return httpProxyAgent;\n  }\n  createConnection(request, options) {\n    let socketPromise;\n    options = Object.assign(Object.assign({}, options), {\n      requestOCSP: true,\n      servername: options.host\n    });\n    if (!!this.proxyInfo) {\n      const httpProxyAgent = WebsocketMessageAdapter.GetProxyAgent(this.proxyInfo);\n      const baseAgent = httpProxyAgent;\n      socketPromise = new Promise((resolve, reject) => {\n        baseAgent.callback(request, options, (error, socket) => {\n          if (!!error) {\n            reject(error);\n          } else {\n            resolve(socket);\n          }\n        });\n      });\n    } else {\n      if (!!options.secureEndpoint) {\n        socketPromise = Promise.resolve(tls.connect(options));\n      } else {\n        socketPromise = Promise.resolve(net.connect(options));\n      }\n    }\n    return socketPromise;\n  }\n  get isWebsocketOpen() {\n    return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;\n  }\n}\nexports.WebsocketMessageAdapter = WebsocketMessageAdapter;\nWebsocketMessageAdapter.forceNpmWebSocket = false;\n\n//# sourceMappingURL=WebsocketMessageAdapter.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}