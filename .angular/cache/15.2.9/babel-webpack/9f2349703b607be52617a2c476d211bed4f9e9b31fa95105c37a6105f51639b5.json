{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PullAudioInputStreamImpl = exports.PullAudioInputStream = exports.PushAudioInputStreamImpl = exports.PushAudioInputStream = exports.AudioInputStream = void 0;\n/* eslint-disable max-classes-per-file */\nconst Exports_js_1 = require(\"../../common.speech/Exports.js\");\nconst Exports_js_2 = require(\"../../common/Exports.js\");\nconst Guid_js_1 = require(\"../../common/Guid.js\");\nconst Exports_js_3 = require(\"../Exports.js\");\nconst AudioStreamFormat_js_1 = require(\"./AudioStreamFormat.js\");\n/**\n * Represents audio input stream used for custom audio input configurations.\n * @class AudioInputStream\n */\nclass AudioInputStream {\n  /**\n   * Creates and initializes an instance.\n   * @constructor\n   */\n  constructor() {\n    return;\n  }\n  /**\n   * Creates a memory backed PushAudioInputStream with the specified audio format.\n   * @member AudioInputStream.createPushStream\n   * @function\n   * @public\n   * @param {AudioStreamFormat} format - The audio data format in which audio will be\n   * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).\n   * @returns {PushAudioInputStream} The audio input stream being created.\n   */\n  static createPushStream(format) {\n    return PushAudioInputStream.create(format);\n  }\n  /**\n   * Creates a PullAudioInputStream that delegates to the specified callback interface for read()\n   * and close() methods.\n   * @member AudioInputStream.createPullStream\n   * @function\n   * @public\n   * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from\n   * PullAudioInputStreamCallback\n   * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from\n   * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n   * @returns {PullAudioInputStream} The audio input stream being created.\n   */\n  static createPullStream(callback, format) {\n    return PullAudioInputStream.create(callback, format);\n    // throw new Error(\"Oops\");\n  }\n}\n\nexports.AudioInputStream = AudioInputStream;\n/**\n * Represents memory backed push audio input stream used for custom audio input configurations.\n * @class PushAudioInputStream\n */\nclass PushAudioInputStream extends AudioInputStream {\n  /**\n   * Creates a memory backed PushAudioInputStream with the specified audio format.\n   * @member PushAudioInputStream.create\n   * @function\n   * @public\n   * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the\n   * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).\n   * @returns {PushAudioInputStream} The push audio input stream being created.\n   */\n  static create(format) {\n    return new PushAudioInputStreamImpl(format);\n  }\n}\nexports.PushAudioInputStream = PushAudioInputStream;\n/**\n * Represents memory backed push audio input stream used for custom audio input configurations.\n * @private\n * @class PushAudioInputStreamImpl\n */\nclass PushAudioInputStreamImpl extends PushAudioInputStream {\n  /**\n   * Creates and initalizes an instance with the given values.\n   * @constructor\n   * @param {AudioStreamFormat} format - The audio stream format.\n   */\n  constructor(format) {\n    super();\n    if (format === undefined) {\n      this.privFormat = AudioStreamFormat_js_1.AudioStreamFormatImpl.getDefaultInputFormat();\n    } else {\n      this.privFormat = format;\n    }\n    this.privEvents = new Exports_js_2.EventSource();\n    this.privId = Guid_js_1.createNoDashGuid();\n    this.privStream = new Exports_js_2.ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);\n  }\n  /**\n   * Format information for the audio\n   */\n  get format() {\n    return Promise.resolve(this.privFormat);\n  }\n  /**\n   * Writes the audio data specified by making an internal copy of the data.\n   * @member PushAudioInputStreamImpl.prototype.write\n   * @function\n   * @public\n   * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.\n   */\n  write(dataBuffer) {\n    this.privStream.writeStreamChunk({\n      buffer: dataBuffer,\n      isEnd: false,\n      timeReceived: Date.now()\n    });\n  }\n  /**\n   * Closes the stream.\n   * @member PushAudioInputStreamImpl.prototype.close\n   * @function\n   * @public\n   */\n  close() {\n    this.privStream.close();\n  }\n  id() {\n    return this.privId;\n  }\n  turnOn() {\n    this.onEvent(new Exports_js_2.AudioSourceInitializingEvent(this.privId)); // no stream id\n    this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));\n    return;\n  }\n  attach(audioNodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.onEvent(new Exports_js_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n      yield this.turnOn();\n      const stream = this.privStream;\n      this.onEvent(new Exports_js_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n      return {\n        detach: () => __awaiter(this, void 0, void 0, function* () {\n          this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n          return this.turnOff();\n        }),\n        id: () => audioNodeId,\n        read: () => stream.read()\n      };\n    });\n  }\n  detach(audioNodeId) {\n    this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n  }\n  turnOff() {\n    return;\n  }\n  get events() {\n    return this.privEvents;\n  }\n  get deviceInfo() {\n    return Promise.resolve({\n      bitspersample: this.privFormat.bitsPerSample,\n      channelcount: this.privFormat.channels,\n      connectivity: Exports_js_1.connectivity.Unknown,\n      manufacturer: \"Speech SDK\",\n      model: \"PushStream\",\n      samplerate: this.privFormat.samplesPerSec,\n      type: Exports_js_1.type.Stream\n    });\n  }\n  onEvent(event) {\n    this.privEvents.onEvent(event);\n    Exports_js_2.Events.instance.onEvent(event);\n  }\n  toBuffer(arrayBuffer) {\n    const buf = Buffer.alloc(arrayBuffer.byteLength);\n    const view = new Uint8Array(arrayBuffer);\n    for (let i = 0; i < buf.length; ++i) {\n      buf[i] = view[i];\n    }\n    return buf;\n  }\n}\nexports.PushAudioInputStreamImpl = PushAudioInputStreamImpl;\n/*\n * Represents audio input stream used for custom audio input configurations.\n * @class PullAudioInputStream\n */\nclass PullAudioInputStream extends AudioInputStream {\n  /**\n   * Creates and initializes and instance.\n   * @constructor\n   */\n  constructor() {\n    super();\n  }\n  /**\n   * Creates a PullAudioInputStream that delegates to the specified callback interface for\n   * read() and close() methods, using the default format (16 kHz 16bit mono PCM).\n   * @member PullAudioInputStream.create\n   * @function\n   * @public\n   * @param {PullAudioInputStreamCallback} callback - The custom audio input object,\n   * derived from PullAudioInputStreamCustomCallback\n   * @param {AudioStreamFormat} format - The audio data format in which audio will be\n   * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n   * @returns {PullAudioInputStream} The push audio input stream being created.\n   */\n  static create(callback, format) {\n    return new PullAudioInputStreamImpl(callback, format);\n  }\n}\nexports.PullAudioInputStream = PullAudioInputStream;\n/**\n * Represents audio input stream used for custom audio input configurations.\n * @private\n * @class PullAudioInputStreamImpl\n */\nclass PullAudioInputStreamImpl extends PullAudioInputStream {\n  /**\n   * Creates a PullAudioInputStream that delegates to the specified callback interface for\n   * read() and close() methods, using the default format (16 kHz 16bit mono PCM).\n   * @constructor\n   * @param {PullAudioInputStreamCallback} callback - The custom audio input object,\n   * derived from PullAudioInputStreamCustomCallback\n   * @param {AudioStreamFormat} format - The audio data format in which audio will be\n   * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n   */\n  constructor(callback, format) {\n    super();\n    if (undefined === format) {\n      this.privFormat = Exports_js_3.AudioStreamFormat.getDefaultInputFormat();\n    } else {\n      this.privFormat = format;\n    }\n    this.privEvents = new Exports_js_2.EventSource();\n    this.privId = Guid_js_1.createNoDashGuid();\n    this.privCallback = callback;\n    this.privIsClosed = false;\n    this.privBufferSize = this.privFormat.avgBytesPerSec / 10;\n  }\n  /**\n   * Format information for the audio\n   */\n  get format() {\n    return Promise.resolve(this.privFormat);\n  }\n  /**\n   * Closes the stream.\n   * @member PullAudioInputStreamImpl.prototype.close\n   * @function\n   * @public\n   */\n  close() {\n    this.privIsClosed = true;\n    this.privCallback.close();\n  }\n  id() {\n    return this.privId;\n  }\n  turnOn() {\n    this.onEvent(new Exports_js_2.AudioSourceInitializingEvent(this.privId)); // no stream id\n    this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));\n    return;\n  }\n  attach(audioNodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.onEvent(new Exports_js_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n      yield this.turnOn();\n      this.onEvent(new Exports_js_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n      return {\n        detach: () => {\n          this.privCallback.close();\n          this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n          return this.turnOff();\n        },\n        id: () => audioNodeId,\n        read: () => {\n          let totalBytes = 0;\n          let transmitBuff;\n          // Until we have the minimum number of bytes to send in a transmission, keep asking for more.\n          while (totalBytes < this.privBufferSize) {\n            // Sizing the read buffer to the delta between the perfect size and what's left means we won't ever get too much\n            // data back.\n            const readBuff = new ArrayBuffer(this.privBufferSize - totalBytes);\n            const pulledBytes = this.privCallback.read(readBuff);\n            // If there is no return buffer yet defined, set the return buffer to the that was just populated.\n            // This was, if we have enough data there's no copy penalty, but if we don't we have a buffer that's the\n            // preferred size allocated.\n            if (undefined === transmitBuff) {\n              transmitBuff = readBuff;\n            } else {\n              // Not the first bite at the apple, so fill the return buffer with the data we got back.\n              const intView = new Int8Array(transmitBuff);\n              intView.set(new Int8Array(readBuff), totalBytes);\n            }\n            // If there are no bytes to read, just break out and be done.\n            if (0 === pulledBytes) {\n              break;\n            }\n            totalBytes += pulledBytes;\n          }\n          return Promise.resolve({\n            buffer: transmitBuff.slice(0, totalBytes),\n            isEnd: this.privIsClosed || totalBytes === 0,\n            timeReceived: Date.now()\n          });\n        }\n      };\n    });\n  }\n  detach(audioNodeId) {\n    this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n  }\n  turnOff() {\n    return;\n  }\n  get events() {\n    return this.privEvents;\n  }\n  get deviceInfo() {\n    return Promise.resolve({\n      bitspersample: this.privFormat.bitsPerSample,\n      channelcount: this.privFormat.channels,\n      connectivity: Exports_js_1.connectivity.Unknown,\n      manufacturer: \"Speech SDK\",\n      model: \"PullStream\",\n      samplerate: this.privFormat.samplesPerSec,\n      type: Exports_js_1.type.Stream\n    });\n  }\n  onEvent(event) {\n    this.privEvents.onEvent(event);\n    Exports_js_2.Events.instance.onEvent(event);\n  }\n}\nexports.PullAudioInputStreamImpl = PullAudioInputStreamImpl;\n\n//# sourceMappingURL=AudioInputStream.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}