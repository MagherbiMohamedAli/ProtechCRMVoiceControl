{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConversationTranslator = exports.SpeechState = void 0;\n/* eslint-disable max-classes-per-file */\nconst Exports_js_1 = require(\"../../common.speech/Exports.js\");\nconst ConversationTranslatorConnectionFactory_js_1 = require(\"../../common.speech/Transcription/ConversationTranslatorConnectionFactory.js\");\nconst Exports_js_2 = require(\"../../common/Exports.js\");\nconst Contracts_js_1 = require(\"../Contracts.js\");\nconst Exports_js_3 = require(\"../Exports.js\");\nconst Conversation_js_1 = require(\"./Conversation.js\");\nconst Exports_js_4 = require(\"./Exports.js\");\nvar SpeechState;\n(function (SpeechState) {\n  SpeechState[SpeechState[\"Inactive\"] = 0] = \"Inactive\";\n  SpeechState[SpeechState[\"Connecting\"] = 1] = \"Connecting\";\n  SpeechState[SpeechState[\"Connected\"] = 2] = \"Connected\";\n})(SpeechState = exports.SpeechState || (exports.SpeechState = {}));\n// child class of TranslationRecognizer meant only for use with ConversationTranslator\nclass ConversationTranslationRecognizer extends Exports_js_3.TranslationRecognizer {\n  constructor(speechConfig, audioConfig, translator, convGetter) {\n    super(speechConfig, audioConfig, new ConversationTranslatorConnectionFactory_js_1.ConversationTranslatorConnectionFactory(convGetter));\n    this.privSpeechState = SpeechState.Inactive;\n    if (!!translator) {\n      this.privTranslator = translator;\n      this.sessionStarted = () => {\n        this.privSpeechState = SpeechState.Connected;\n      };\n      this.sessionStopped = () => {\n        this.privSpeechState = SpeechState.Inactive;\n      };\n      this.recognizing = (tr, e) => {\n        if (!!this.privTranslator.recognizing) {\n          this.privTranslator.recognizing(this.privTranslator, e);\n        }\n      };\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      this.recognized = (tr, e) => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        // if there is an error connecting to the conversation service from the speech service the error will be returned in the ErrorDetails field.\n        if ((_a = e.result) === null || _a === void 0 ? void 0 : _a.errorDetails) {\n          yield this.cancelSpeech();\n          // TODO: format the error message contained in 'errorDetails'\n          this.fireCancelEvent(e.result.errorDetails);\n        } else {\n          if (!!this.privTranslator.recognized) {\n            this.privTranslator.recognized(this.privTranslator, e);\n          }\n        }\n        return;\n      });\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      this.canceled = () => __awaiter(this, void 0, void 0, function* () {\n        if (this.privSpeechState !== SpeechState.Inactive) {\n          try {\n            yield this.cancelSpeech();\n          } catch (error) {\n            this.privSpeechState = SpeechState.Inactive;\n          }\n        }\n      });\n    }\n  }\n  get state() {\n    return this.privSpeechState;\n  }\n  set state(newState) {\n    this.privSpeechState = newState;\n  }\n  set authentication(token) {\n    this.privReco.authentication = token;\n  }\n  onConnection() {\n    this.privSpeechState = SpeechState.Connected;\n  }\n  onCancelSpeech() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privSpeechState = SpeechState.Inactive;\n      yield this.cancelSpeech();\n    });\n  }\n  /**\n   * Fire a cancel event\n   * @param error\n   */\n  fireCancelEvent(error) {\n    try {\n      if (!!this.privTranslator.canceled) {\n        const cancelEvent = new Exports_js_4.ConversationTranslationCanceledEventArgs(Exports_js_3.CancellationReason.Error, error, Exports_js_3.CancellationErrorCode.RuntimeError);\n        this.privTranslator.canceled(this.privTranslator, cancelEvent);\n      }\n    } catch (e) {\n      //\n    }\n  }\n  cancelSpeech() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.stopContinuousRecognitionAsync();\n        yield (_a = this.privReco) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this.privSpeechState = SpeechState.Inactive;\n      } catch (e) {\n        // ignore the error\n      }\n    });\n  }\n}\n/**\n * Join, leave or connect to a conversation.\n */\nclass ConversationTranslator extends Exports_js_4.ConversationCommon {\n  constructor(audioConfig) {\n    super(audioConfig);\n    this.privErrors = Exports_js_1.ConversationConnectionConfig.restErrors;\n    this.privIsDisposed = false;\n    this.privIsSpeaking = false;\n    this.privPlaceholderKey = \"abcdefghijklmnopqrstuvwxyz012345\";\n    this.privPlaceholderRegion = \"westus\";\n    this.privProperties = new Exports_js_3.PropertyCollection();\n  }\n  get properties() {\n    return this.privProperties;\n  }\n  get speechRecognitionLanguage() {\n    return this.privSpeechRecognitionLanguage;\n  }\n  get participants() {\n    var _a;\n    return (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.participants;\n  }\n  get canSpeak() {\n    // is there a Conversation websocket available and has the Recognizer been set up\n    if (!this.privConversation.isConnected || !this.privCTRecognizer) {\n      return false;\n    }\n    // is the user already speaking\n    if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) {\n      return false;\n    }\n    // is the user muted\n    if (this.privConversation.isMutedByHost) {\n      return false;\n    }\n    return true;\n  }\n  onToken(token) {\n    this.privCTRecognizer.authentication = token;\n  }\n  setServiceProperty(name, value) {\n    const currentProperties = JSON.parse(this.privProperties.getProperty(Exports_js_1.ServicePropertiesPropertyName, \"{}\"));\n    currentProperties[name] = value;\n    this.privProperties.setProperty(Exports_js_1.ServicePropertiesPropertyName, JSON.stringify(currentProperties));\n  }\n  joinConversationAsync(conversation, nickname, param1, param2, param3) {\n    try {\n      if (typeof conversation === \"string\") {\n        Contracts_js_1.Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n        Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n        if (!!this.privConversation) {\n          this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);\n        }\n        let lang = param1;\n        if (lang === undefined || lang === null || lang === \"\") {\n          lang = Exports_js_1.ConversationConnectionConfig.defaultLanguageCode;\n        }\n        // create a placeholder config\n        this.privSpeechTranslationConfig = Exports_js_3.SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion);\n        this.privSpeechTranslationConfig.setProfanity(Exports_js_3.ProfanityOption.Masked);\n        this.privSpeechTranslationConfig.addTargetLanguage(lang);\n        this.privSpeechTranslationConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage], lang);\n        this.privSpeechTranslationConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.ConversationTranslator_Name], nickname);\n        const propertyIdsToCopy = [Exports_js_3.PropertyId.SpeechServiceConnection_Host, Exports_js_3.PropertyId.ConversationTranslator_Host, Exports_js_3.PropertyId.SpeechServiceConnection_Endpoint, Exports_js_3.PropertyId.SpeechServiceConnection_ProxyHostName, Exports_js_3.PropertyId.SpeechServiceConnection_ProxyPassword, Exports_js_3.PropertyId.SpeechServiceConnection_ProxyPort, Exports_js_3.PropertyId.SpeechServiceConnection_ProxyUserName, \"ConversationTranslator_MultiChannelAudio\", \"ConversationTranslator_Region\"];\n        for (const prop of propertyIdsToCopy) {\n          const value = this.privProperties.getProperty(prop);\n          if (value) {\n            const key = typeof prop === \"string\" ? prop : Exports_js_3.PropertyId[prop];\n            this.privSpeechTranslationConfig.setProperty(key, value);\n          }\n        }\n        const currentProperties = JSON.parse(this.privProperties.getProperty(Exports_js_1.ServicePropertiesPropertyName, \"{}\"));\n        for (const prop of Object.keys(currentProperties)) {\n          this.privSpeechTranslationConfig.setServiceProperty(prop, currentProperties[prop], Exports_js_3.ServicePropertyChannel.UriQueryParameter);\n        }\n        // join the conversation\n        this.privConversation = new Conversation_js_1.ConversationImpl(this.privSpeechTranslationConfig);\n        this.privConversation.conversationTranslator = this;\n        this.privConversation.joinConversationAsync(conversation, nickname, lang, result => {\n          if (!result) {\n            this.handleError(new Error(this.privErrors.permissionDeniedConnect), param3);\n          }\n          this.privSpeechTranslationConfig.authorizationToken = result;\n          this.privConversation.room.isHost = false;\n          // connect to the ws\n          this.privConversation.startConversationAsync(() => {\n            this.handleCallback(param2, param3);\n          }, error => {\n            this.handleError(error, param3);\n          });\n        }, error => {\n          this.handleError(error, param3);\n        });\n      } else if (typeof conversation === \"object\") {\n        Contracts_js_1.Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n        Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n        // save the nickname\n        this.privProperties.setProperty(Exports_js_3.PropertyId.ConversationTranslator_Name, nickname);\n        // ref the conversation object\n        this.privConversation = conversation;\n        // ref the conversation translator object\n        this.privConversation.conversationTranslator = this;\n        this.privConversation.room.isHost = true;\n        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);\n        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n        this.privSpeechTranslationConfig = conversation.config;\n        this.handleCallback(param1, param2);\n      } else {\n        this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"invalid conversation type\")), param2);\n      }\n    } catch (error) {\n      this.handleError(error, typeof param1 === \"string\" ? param3 : param2);\n    }\n  }\n  /**\n   * Leave the conversation\n   * @param cb\n   * @param err\n   */\n  leaveConversationAsync(cb, err) {\n    Exports_js_2.marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      // stop the speech websocket\n      yield this.cancelSpeech();\n      // stop the websocket\n      yield this.privConversation.endConversationImplAsync();\n      // https delete request\n      yield this.privConversation.deleteConversationImplAsync();\n      this.dispose();\n    }))(), cb, err);\n  }\n  /**\n   * Send a text message\n   * @param message\n   * @param cb\n   * @param err\n   */\n  sendTextMessageAsync(message, cb, err) {\n    try {\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n      Contracts_js_1.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", message));\n      this.privConversation.sendTextMessageAsync(message, cb, err);\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Start speaking\n   * @param cb\n   * @param err\n   */\n  startTranscribingAsync(cb, err) {\n    Exports_js_2.marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      try {\n        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n        if (this.privCTRecognizer === undefined) {\n          yield this.connectTranslatorRecognizer();\n        }\n        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);\n        if (!this.canSpeak) {\n          this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n        }\n        yield this.startContinuousRecognition();\n        this.privIsSpeaking = true;\n      } catch (error) {\n        this.privIsSpeaking = false;\n        yield this.cancelSpeech();\n        throw error;\n      }\n    }))(), cb, err);\n  }\n  /**\n   * Stop speaking\n   * @param cb\n   * @param err\n   */\n  stopTranscribingAsync(cb, err) {\n    Exports_js_2.marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!this.privIsSpeaking) {\n          // stop speech\n          yield this.cancelSpeech();\n          return;\n        }\n        // stop the recognition but leave the websocket open\n        this.privIsSpeaking = false;\n        yield new Promise((resolve, reject) => {\n          this.privCTRecognizer.stopContinuousRecognitionAsync(resolve, reject);\n        });\n      } catch (error) {\n        yield this.cancelSpeech();\n      }\n    }))(), cb, err);\n  }\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n  dispose(reason, success, err) {\n    Exports_js_2.marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed && !this.privIsSpeaking) {\n        return;\n      }\n      yield this.cancelSpeech();\n      this.privIsDisposed = true;\n      this.privSpeechTranslationConfig.close();\n      this.privSpeechRecognitionLanguage = undefined;\n      this.privProperties = undefined;\n      this.privAudioConfig = undefined;\n      this.privSpeechTranslationConfig = undefined;\n      this.privConversation.dispose();\n      this.privConversation = undefined;\n    }))(), success, err);\n  }\n  /**\n   * Cancel the speech websocket\n   */\n  cancelSpeech() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.privIsSpeaking = false;\n        yield (_a = this.privCTRecognizer) === null || _a === void 0 ? void 0 : _a.onCancelSpeech();\n        this.privCTRecognizer = undefined;\n      } catch (e) {\n        // ignore the error\n      }\n    });\n  }\n  /**\n   * Connect to the speech translation recognizer.\n   * Currently there is no language validation performed before sending the SpeechLanguage code to the service.\n   * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'\n   * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'\n   */\n  connectTranslatorRecognizer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this.privAudioConfig === undefined) {\n          this.privAudioConfig = Exports_js_3.AudioConfig.fromDefaultMicrophoneInput();\n        }\n        // clear the temp subscription key if it's a participant joining\n        if (this.privSpeechTranslationConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey) {\n          this.privSpeechTranslationConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_Key], \"\");\n        }\n        const convGetter = () => this.privConversation;\n        this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this, convGetter);\n      } catch (error) {\n        yield this.cancelSpeech();\n        throw error;\n      }\n    });\n  }\n  /**\n   * Handle the start speaking request\n   */\n  startContinuousRecognition() {\n    return new Promise((resolve, reject) => {\n      this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);\n    });\n  }\n}\nexports.ConversationTranslator = ConversationTranslator;\n\n//# sourceMappingURL=ConversationTranslator.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}