{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Queue = void 0;\nconst Error_js_1 = require(\"./Error.js\");\nconst List_js_1 = require(\"./List.js\");\nconst Promise_js_1 = require(\"./Promise.js\");\nvar SubscriberType = /*#__PURE__*/(() => {\n  (function (SubscriberType) {\n    SubscriberType[SubscriberType[\"Dequeue\"] = 0] = \"Dequeue\";\n    SubscriberType[SubscriberType[\"Peek\"] = 1] = \"Peek\";\n  })(SubscriberType || (SubscriberType = {}));\n  return SubscriberType;\n})();\nclass Queue {\n  constructor(list) {\n    this.privPromiseStore = new List_js_1.List();\n    this.privIsDrainInProgress = false;\n    this.privIsDisposing = false;\n    this.privDisposeReason = null;\n    this.privList = list ? list : new List_js_1.List();\n    this.privDetachables = [];\n    this.privSubscribers = new List_js_1.List();\n    this.privDetachables.push(this.privList.onAdded(() => this.drain()));\n  }\n  enqueue(item) {\n    this.throwIfDispose();\n    this.enqueueFromPromise(new Promise(resolve => resolve(item)));\n  }\n  enqueueFromPromise(promise) {\n    this.throwIfDispose();\n    promise.then(val => {\n      this.privList.add(val);\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n    }, () => {});\n  }\n  dequeue() {\n    this.throwIfDispose();\n    const deferredSubscriber = new Promise_js_1.Deferred();\n    if (this.privSubscribers) {\n      this.privSubscribers.add({\n        deferral: deferredSubscriber,\n        type: SubscriberType.Dequeue\n      });\n      this.drain();\n    }\n    return deferredSubscriber.promise;\n  }\n  peek() {\n    this.throwIfDispose();\n    const deferredSubscriber = new Promise_js_1.Deferred();\n    const subs = this.privSubscribers;\n    if (subs) {\n      this.privSubscribers.add({\n        deferral: deferredSubscriber,\n        type: SubscriberType.Peek\n      });\n      this.drain();\n    }\n    return deferredSubscriber.promise;\n  }\n  length() {\n    this.throwIfDispose();\n    return this.privList.length();\n  }\n  isDisposed() {\n    return this.privSubscribers == null;\n  }\n  drainAndDispose(pendingItemProcessor, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isDisposed() && !this.privIsDisposing) {\n        this.privDisposeReason = reason;\n        this.privIsDisposing = true;\n        const subs = this.privSubscribers;\n        if (subs) {\n          while (subs.length() > 0) {\n            const subscriber = subs.removeFirst();\n            // TODO: this needs work (Resolve(null) instead?).\n            subscriber.deferral.resolve(undefined);\n            // subscriber.deferral.reject(\"Disposed\");\n          }\n          // note: this block assumes cooperative multitasking, i.e.,\n          // between the if-statement and the assignment there are no\n          // thread switches.\n          // Reason is that between the initial const = this.; and this\n          // point there is the derral.resolve() operation that might have\n          // caused recursive calls to the Queue, especially, calling\n          // Dispose() on the queue alredy (which would reset the var\n          // here to null!).\n          // That should generally hold true for javascript...\n          if (this.privSubscribers === subs) {\n            this.privSubscribers = subs;\n          }\n        }\n        for (const detachable of this.privDetachables) {\n          yield detachable.detach();\n        }\n        if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {\n          const promiseArray = [];\n          this.privPromiseStore.toArray().forEach(wrapper => {\n            promiseArray.push(wrapper);\n          });\n          return Promise.all(promiseArray).finally(() => {\n            this.privSubscribers = null;\n            this.privList.forEach(item => {\n              pendingItemProcessor(item);\n            });\n            this.privList = null;\n            return;\n          }).then();\n        } else {\n          this.privSubscribers = null;\n          this.privList = null;\n        }\n      }\n    });\n  }\n  dispose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.drainAndDispose(null, reason);\n    });\n  }\n  drain() {\n    if (!this.privIsDrainInProgress && !this.privIsDisposing) {\n      this.privIsDrainInProgress = true;\n      const subs = this.privSubscribers;\n      const lists = this.privList;\n      if (subs && lists) {\n        while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {\n          const subscriber = subs.removeFirst();\n          if (subscriber.type === SubscriberType.Peek) {\n            subscriber.deferral.resolve(lists.first());\n          } else {\n            const dequeuedItem = lists.removeFirst();\n            subscriber.deferral.resolve(dequeuedItem);\n          }\n        }\n        // note: this block assumes cooperative multitasking, i.e.,\n        // between the if-statement and the assignment there are no\n        // thread switches.\n        // Reason is that between the initial const = this.; and this\n        // point there is the derral.resolve() operation that might have\n        // caused recursive calls to the Queue, especially, calling\n        // Dispose() on the queue alredy (which would reset the var\n        // here to null!).\n        // That should generally hold true for javascript...\n        if (this.privSubscribers === subs) {\n          this.privSubscribers = subs;\n        }\n        // note: this block assumes cooperative multitasking, i.e.,\n        // between the if-statement and the assignment there are no\n        // thread switches.\n        // Reason is that between the initial const = this.; and this\n        // point there is the derral.resolve() operation that might have\n        // caused recursive calls to the Queue, especially, calling\n        // Dispose() on the queue alredy (which would reset the var\n        // here to null!).\n        // That should generally hold true for javascript...\n        if (this.privList === lists) {\n          this.privList = lists;\n        }\n      }\n      this.privIsDrainInProgress = false;\n    }\n  }\n  throwIfDispose() {\n    if (this.isDisposed()) {\n      if (this.privDisposeReason) {\n        throw new Error_js_1.InvalidOperationError(this.privDisposeReason);\n      }\n      throw new Error_js_1.ObjectDisposedError(\"Queue\");\n    } else if (this.privIsDisposing) {\n      throw new Error_js_1.InvalidOperationError(\"Queue disposing\");\n    }\n  }\n}\nexports.Queue = Queue;\n\n//# sourceMappingURL=Queue.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}