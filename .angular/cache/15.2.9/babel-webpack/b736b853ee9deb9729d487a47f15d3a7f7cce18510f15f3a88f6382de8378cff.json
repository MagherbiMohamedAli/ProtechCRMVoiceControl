{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RequestSession = void 0;\nconst Exports_js_1 = require(\"../common/Exports.js\");\nconst RecognitionEvents_js_1 = require(\"./RecognitionEvents.js\");\nconst ServiceTelemetryListener_Internal_js_1 = require(\"./ServiceTelemetryListener.Internal.js\");\nclass RequestSession {\n  constructor(audioSourceId) {\n    this.privIsDisposed = false;\n    this.privDetachables = new Array();\n    this.privIsAudioNodeDetached = false;\n    this.privIsRecognizing = false;\n    this.privIsSpeechEnded = false;\n    this.privTurnStartAudioOffset = 0;\n    this.privLastRecoOffset = 0;\n    this.privHypothesisReceived = false;\n    this.privBytesSent = 0;\n    this.privRecognitionBytesSent = 0;\n    this.privRecogNumber = 0;\n    this.privInTurn = false;\n    this.privConnectionAttempts = 0;\n    this.privAudioSourceId = audioSourceId;\n    this.privRequestId = Exports_js_1.createNoDashGuid();\n    this.privAudioNodeId = Exports_js_1.createNoDashGuid();\n    this.privTurnDeferral = new Exports_js_1.Deferred();\n    // We're not in a turn, so resolve.\n    this.privTurnDeferral.resolve();\n  }\n  get sessionId() {\n    return this.privSessionId;\n  }\n  get requestId() {\n    return this.privRequestId;\n  }\n  get audioNodeId() {\n    return this.privAudioNodeId;\n  }\n  get turnCompletionPromise() {\n    return this.privTurnDeferral.promise;\n  }\n  get isSpeechEnded() {\n    return this.privIsSpeechEnded;\n  }\n  get isRecognizing() {\n    return this.privIsRecognizing;\n  }\n  get currentTurnAudioOffset() {\n    return this.privTurnStartAudioOffset;\n  }\n  get recogNumber() {\n    return this.privRecogNumber;\n  }\n  get numConnectionAttempts() {\n    return this.privConnectionAttempts;\n  }\n  // The number of bytes sent for the current connection.\n  // Counter is reset to 0 each time a connection is established.\n  get bytesSent() {\n    return this.privBytesSent;\n  }\n  // The number of bytes sent for the current recognition.\n  // Counter is reset to 0 each time recognition is started.\n  get recognitionBytesSent() {\n    return this.privRecognitionBytesSent;\n  }\n  listenForServiceTelemetry(eventSource) {\n    if (!!this.privServiceTelemetryListener) {\n      this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\n    }\n  }\n  startNewRecognition() {\n    this.privRecognitionBytesSent = 0;\n    this.privIsSpeechEnded = false;\n    this.privIsRecognizing = true;\n    this.privTurnStartAudioOffset = 0;\n    this.privLastRecoOffset = 0;\n    this.privRecogNumber++;\n    this.privServiceTelemetryListener = new ServiceTelemetryListener_Internal_js_1.ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\n    this.onEvent(new RecognitionEvents_js_1.RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n  }\n  onAudioSourceAttachCompleted(audioNode, isError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privAudioNode = audioNode;\n      this.privIsAudioNodeDetached = false;\n      if (isError) {\n        yield this.onComplete();\n      } else {\n        this.onEvent(new RecognitionEvents_js_1.ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n      }\n    });\n  }\n  onPreConnectionStart(authFetchEventId, connectionId) {\n    this.privAuthFetchEventId = authFetchEventId;\n    this.privSessionId = connectionId;\n    this.onEvent(new RecognitionEvents_js_1.ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));\n  }\n  onAuthCompleted(isError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isError) {\n        yield this.onComplete();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onConnectionEstablishCompleted(statusCode, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (statusCode === 200) {\n        this.onEvent(new RecognitionEvents_js_1.RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));\n        if (!!this.privAudioNode) {\n          this.privAudioNode.replay();\n        }\n        this.privTurnStartAudioOffset = this.privLastRecoOffset;\n        this.privBytesSent = 0;\n        return;\n      } else if (statusCode === 403) {\n        yield this.onComplete();\n      }\n    });\n  }\n  onServiceTurnEndResponse(continuousRecognition) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privTurnDeferral.resolve();\n      if (!continuousRecognition || this.isSpeechEnded) {\n        yield this.onComplete();\n        this.privInTurn = false;\n      } else {\n        // Start a new request set.\n        this.privTurnStartAudioOffset = this.privLastRecoOffset;\n        this.privAudioNode.replay();\n      }\n    });\n  }\n  onSpeechContext() {\n    this.privRequestId = Exports_js_1.createNoDashGuid();\n  }\n  onServiceTurnStartResponse() {\n    if (!!this.privTurnDeferral && !!this.privInTurn) {\n      // What? How are we starting a turn with another not done?\n      this.privTurnDeferral.reject(\"Another turn started before current completed.\");\n      // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      this.privTurnDeferral.promise.then().catch(() => {});\n    }\n    this.privInTurn = true;\n    this.privTurnDeferral = new Exports_js_1.Deferred();\n  }\n  onHypothesis(offset) {\n    if (!this.privHypothesisReceived) {\n      this.privHypothesisReceived = true;\n      this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\n    }\n  }\n  onPhraseRecognized(offset) {\n    this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\n    this.onServiceRecognized(offset);\n  }\n  onServiceRecognized(offset) {\n    this.privLastRecoOffset = offset;\n    this.privHypothesisReceived = false;\n    this.privAudioNode.shrinkBuffers(offset);\n    this.privConnectionAttempts = 0;\n  }\n  onAudioSent(bytesSent) {\n    this.privBytesSent += bytesSent;\n    this.privRecognitionBytesSent += bytesSent;\n  }\n  onRetryConnection() {\n    this.privConnectionAttempts++;\n  }\n  dispose() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privIsDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        this.privIsDisposed = true;\n        for (const detachable of this.privDetachables) {\n          yield detachable.detach();\n        }\n        if (!!this.privServiceTelemetryListener) {\n          this.privServiceTelemetryListener.dispose();\n        }\n        this.privIsRecognizing = false;\n      }\n    });\n  }\n  getTelemetry() {\n    if (this.privServiceTelemetryListener.hasTelemetry) {\n      return this.privServiceTelemetryListener.getTelemetry();\n    } else {\n      return null;\n    }\n  }\n  onStopRecognizing() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.onComplete();\n    });\n  }\n  // Should be called with the audioNode for this session has indicated that it is out of speech.\n  onSpeechEnded() {\n    this.privIsSpeechEnded = true;\n  }\n  onEvent(event) {\n    if (!!this.privServiceTelemetryListener) {\n      this.privServiceTelemetryListener.onEvent(event);\n    }\n    Exports_js_1.Events.instance.onEvent(event);\n  }\n  onComplete() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privIsRecognizing) {\n        this.privIsRecognizing = false;\n        yield this.detachAudioNode();\n      }\n    });\n  }\n  detachAudioNode() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privIsAudioNodeDetached) {\n        this.privIsAudioNodeDetached = true;\n        if (this.privAudioNode) {\n          yield this.privAudioNode.detach();\n        }\n      }\n    });\n  }\n}\nexports.RequestSession = RequestSession;\n\n//# sourceMappingURL=RequestSession.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}