{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FileAudioSource = void 0;\nconst Exports_js_1 = require(\"../common.speech/Exports.js\");\nconst Exports_js_2 = require(\"../common/Exports.js\");\nconst AudioStreamFormat_js_1 = require(\"../sdk/Audio/AudioStreamFormat.js\");\nclass FileAudioSource {\n  constructor(file, filename, audioSourceId) {\n    this.privStreams = {};\n    this.privHeaderEnd = 44;\n    this.privId = audioSourceId ? audioSourceId : Exports_js_2.createNoDashGuid();\n    this.privEvents = new Exports_js_2.EventSource();\n    this.privSource = file;\n    if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\n      this.privFilename = file.name;\n    } else {\n      this.privFilename = filename || \"unknown.wav\";\n    }\n    // Read the header.\n    this.privAudioFormatPromise = this.readHeader();\n  }\n  get format() {\n    return this.privAudioFormatPromise;\n  }\n  turnOn() {\n    if (this.privFilename.lastIndexOf(\".wav\") !== this.privFilename.length - 4) {\n      const errorMsg = this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\n      this.onEvent(new Exports_js_2.AudioSourceErrorEvent(errorMsg, \"\"));\n      return Promise.reject(errorMsg);\n    }\n    this.onEvent(new Exports_js_2.AudioSourceInitializingEvent(this.privId)); // no stream id\n    this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));\n    return;\n  }\n  id() {\n    return this.privId;\n  }\n  attach(audioNodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.onEvent(new Exports_js_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n      const stream = yield this.upload(audioNodeId);\n      this.onEvent(new Exports_js_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n      return Promise.resolve({\n        detach: () => __awaiter(this, void 0, void 0, function* () {\n          stream.readEnded();\n          delete this.privStreams[audioNodeId];\n          this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n          yield this.turnOff();\n        }),\n        id: () => audioNodeId,\n        read: () => stream.read()\n      });\n    });\n  }\n  detach(audioNodeId) {\n    if (audioNodeId && this.privStreams[audioNodeId]) {\n      this.privStreams[audioNodeId].close();\n      delete this.privStreams[audioNodeId];\n      this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n    }\n  }\n  turnOff() {\n    for (const streamId in this.privStreams) {\n      if (streamId) {\n        const stream = this.privStreams[streamId];\n        if (stream && !stream.isClosed) {\n          stream.close();\n        }\n      }\n    }\n    this.onEvent(new Exports_js_2.AudioSourceOffEvent(this.privId)); // no stream now\n    return Promise.resolve();\n  }\n  get events() {\n    return this.privEvents;\n  }\n  get deviceInfo() {\n    return this.privAudioFormatPromise.then(result => Promise.resolve({\n      bitspersample: result.bitsPerSample,\n      channelcount: result.channels,\n      connectivity: Exports_js_1.connectivity.Unknown,\n      manufacturer: \"Speech SDK\",\n      model: \"File\",\n      samplerate: result.samplesPerSec,\n      type: Exports_js_1.type.File\n    }));\n  }\n  readHeader() {\n    // Read the wave header.\n    const maxHeaderSize = 4296;\n    const header = this.privSource.slice(0, maxHeaderSize);\n    const headerResult = new Exports_js_2.Deferred();\n    const processHeader = header => {\n      const view = new DataView(header);\n      const getWord = index => String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\n      // RIFF 4 bytes.\n      if (\"RIFF\" !== getWord(0)) {\n        headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\n        return;\n      }\n      // length, 4 bytes\n      // RIFF Type & fmt 8 bytes\n      if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\n        headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\n        return;\n      }\n      const formatSize = view.getInt32(16, true);\n      const channelCount = view.getUint16(22, true);\n      const sampleRate = view.getUint32(24, true);\n      const bitsPerSample = view.getUint16(34, true);\n      // Confirm if header is 44 bytes long.\n      let pos = 36 + Math.max(formatSize - 16, 0);\n      for (; getWord(pos) !== \"data\"; pos += 2) {\n        if (pos > maxHeaderSize - 8) {\n          headerResult.reject(\"Invalid WAV header in file, data block was not found\");\n          return;\n        }\n      }\n      this.privHeaderEnd = pos + 8;\n      headerResult.resolve(AudioStreamFormat_js_1.AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));\n    };\n    if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\n      const reader = new FileReader();\n      reader.onload = event => {\n        const header = event.target.result;\n        processHeader(header);\n      };\n      reader.readAsArrayBuffer(header);\n    } else {\n      const h = header;\n      processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\n    }\n    return headerResult.promise;\n  }\n  upload(audioNodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const onerror = error => {\n        const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;\n        this.onEvent(new Exports_js_2.AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\n        throw new Error(errorMsg);\n      };\n      try {\n        yield this.turnOn();\n        const format = yield this.privAudioFormatPromise;\n        const stream = new Exports_js_2.ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\n        this.privStreams[audioNodeId] = stream;\n        const chunk = this.privSource.slice(this.privHeaderEnd);\n        const processFile = buff => {\n          if (stream.isClosed) {\n            return; // output stream was closed (somebody called TurnOff). We're done here.\n          }\n\n          stream.writeStreamChunk({\n            buffer: buff,\n            isEnd: false,\n            timeReceived: Date.now()\n          });\n          stream.close();\n        };\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\n          const reader = new FileReader();\n          reader.onerror = ev => onerror(ev.toString());\n          reader.onload = event => {\n            const fileBuffer = event.target.result;\n            processFile(fileBuffer);\n          };\n          reader.readAsArrayBuffer(chunk);\n        } else {\n          const c = chunk;\n          processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\n        }\n        return stream;\n      } catch (e) {\n        onerror(e);\n      }\n    });\n  }\n  onEvent(event) {\n    this.privEvents.onEvent(event);\n    Exports_js_2.Events.instance.onEvent(event);\n  }\n}\nexports.FileAudioSource = FileAudioSource;\n\n//# sourceMappingURL=FileAudioSource.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}