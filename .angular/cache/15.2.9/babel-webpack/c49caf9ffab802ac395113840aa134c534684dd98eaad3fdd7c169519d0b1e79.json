{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConversationServiceAdapter = void 0;\nconst Exports_js_1 = require(\"../../common/Exports.js\");\nconst Exports_js_2 = require(\"../../sdk/Exports.js\");\nconst Exports_js_3 = require(\"../Exports.js\");\nconst ConversationConnectionMessage_js_1 = require(\"./ConversationConnectionMessage.js\");\nconst ConversationRequestSession_js_1 = require(\"./ConversationRequestSession.js\");\nconst ConversationTranslatorEventArgs_js_1 = require(\"./ConversationTranslatorEventArgs.js\");\nconst ConversationTranslatorInterfaces_js_1 = require(\"./ConversationTranslatorInterfaces.js\");\nconst Exports_js_4 = require(\"./ServiceMessages/Exports.js\");\n/**\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\n */\nclass ConversationServiceAdapter extends Exports_js_3.ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\n    this.privConnectionConfigPromise = undefined;\n    this.privLastPartialUtteranceId = \"\";\n    this.privConversationServiceConnector = conversationServiceConnector;\n    this.privConversationAuthentication = authentication;\n    this.receiveMessageOverride = () => this.receiveConversationMessageOverride();\n    this.recognizeOverride = () => this.noOp();\n    this.postConnectImplOverride = connection => this.conversationConnectImpl(connection);\n    this.configConnectionOverride = () => this.configConnection();\n    this.disconnectOverride = () => this.privDisconnect();\n    this.privConversationRequestSession = new ConversationRequestSession_js_1.ConversationRequestSession(Exports_js_1.createNoDashGuid());\n    this.privConversationConnectionFactory = connectionFactory;\n    this.privConversationIsDisposed = false;\n  }\n  isDisposed() {\n    return super.isDisposed() || this.privConversationIsDisposed;\n  }\n  dispose(reason) {\n    const _super = Object.create(null, {\n      dispose: {\n        get: () => super.dispose\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privConversationIsDisposed = true;\n      if (this.privConnectionConfigPromise !== undefined) {\n        const connection = yield this.privConnectionConfigPromise;\n        yield connection.dispose(reason);\n      }\n      yield _super.dispose.call(this, reason);\n    });\n  }\n  sendMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      return connection.send(new ConversationConnectionMessage_js_1.ConversationConnectionMessage(Exports_js_1.MessageType.Text, message));\n    });\n  }\n  sendMessageAsync(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      yield connection.send(new ConversationConnectionMessage_js_1.ConversationConnectionMessage(Exports_js_1.MessageType.Text, message));\n    });\n  }\n  privDisconnect() {\n    if (this.terminateMessageLoop) {\n      return;\n    }\n    this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, Exports_js_2.CancellationReason.Error, Exports_js_2.CancellationErrorCode.NoError, \"Disconnecting\");\n    this.terminateMessageLoop = true;\n    return Promise.resolve();\n  }\n  // eslint-disable-next-line @typescript-eslint/require-await\n  processTypeSpecificMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return true;\n    });\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    this.terminateMessageLoop = true;\n    const cancelEvent = new Exports_js_2.ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n    try {\n      if (!!this.privConversationServiceConnector.canceled) {\n        this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\n      }\n    } catch (_a) {\n      // continue on error\n    }\n  }\n  /**\n   * Establishes a websocket connection to the end point.\n   */\n  conversationConnectImpl(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privConnectionLoop = this.startMessageLoop();\n      return connection;\n    });\n  }\n  /**\n   * Process incoming websocket messages\n   */\n  receiveConversationMessageOverride() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed() || this.terminateMessageLoop) {\n        return Promise.resolve();\n      }\n      // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n      const communicationCustodian = new Exports_js_1.Deferred();\n      try {\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n        if (this.isDisposed() || this.terminateMessageLoop) {\n          // We're done.\n          communicationCustodian.resolve();\n          return Promise.resolve();\n        }\n        if (!message) {\n          return this.receiveConversationMessageOverride();\n        }\n        const sessionId = this.privConversationRequestSession.sessionId;\n        const conversationMessageType = message.conversationMessageType.toLowerCase();\n        let sendFinal = false;\n        try {\n          switch (conversationMessageType) {\n            case \"info\":\n            case \"participant_command\":\n            case \"command\":\n              const commandPayload = Exports_js_4.CommandResponsePayload.fromJSON(message.textBody);\n              switch (commandPayload.command.toLowerCase()) {\n                /**\n                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\n                 * The consuming client must wait for this message to arrive\n                 * before starting to send their own data.\n                 */\n                case \"participantlist\":\n                  const participantsPayload = Exports_js_4.ParticipantsListPayloadResponse.fromJSON(message.textBody);\n                  const participantsResult = participantsPayload.participants.map(p => {\n                    const participant = {\n                      avatar: p.avatar,\n                      displayName: p.nickname,\n                      id: p.participantId,\n                      isHost: p.ishost,\n                      isMuted: p.ismuted,\n                      isUsingTts: p.usetts,\n                      preferredLanguage: p.locale\n                    };\n                    return participant;\n                  });\n                  if (!!this.privConversationServiceConnector.participantsListReceived) {\n                    this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\n                 * This is sent at the start of the Conversation\n                 */\n                case \"settranslatetolanguages\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\n                 * If sent by the participant the setting will effect only their own profanity level.\n                 * If sent by the host, the setting will effect all participants including the host.\n                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\n                 */\n                case \"setprofanityfiltering\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetMute' is sent if the participant has been muted by the host.\n                 * Check the 'participantId' to determine if the current user has been muted.\n                 */\n                case \"setmute\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.\n                 */\n                case \"setmuteall\":\n                  if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\n                    this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.MuteAllEventArgs(commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\n                 */\n                case \"roomexpirationwarning\":\n                  if (!!this.privConversationServiceConnector.conversationExpiration) {\n                    this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new Exports_js_2.ConversationExpirationEventArgs(commandPayload.value, this.privConversationRequestSession.sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\n                 */\n                case \"setusetts\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.\n                 */\n                case \"setlockstate\":\n                  if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\n                    this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.LockRoomEventArgs(commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'ChangeNickname' is received if a user changes their display name.\n                 * Any cached particpiants list should be updated to reflect the display name.\n                 */\n                case \"changenickname\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.changeNickname, commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'JoinSession' is sent when a user joins the Conversation.\n                 */\n                case \"joinsession\":\n                  const joinParticipantPayload = Exports_js_4.ParticipantPayloadResponse.fromJSON(message.textBody);\n                  const joiningParticipant = {\n                    avatar: joinParticipantPayload.avatar,\n                    displayName: joinParticipantPayload.nickname,\n                    id: joinParticipantPayload.participantId,\n                    isHost: joinParticipantPayload.ishost,\n                    isMuted: joinParticipantPayload.ismuted,\n                    isUsingTts: joinParticipantPayload.usetts,\n                    preferredLanguage: joinParticipantPayload.locale\n                  };\n                  if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\n                    this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantEventArgs(joiningParticipant, sessionId));\n                  }\n                  break;\n                /**\n                 * 'LeaveSession' is sent when a user leaves the Conversation'.\n                 */\n                case \"leavesession\":\n                  const leavingParticipant = {\n                    id: commandPayload.participantId\n                  };\n                  if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\n                    this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantEventArgs(leavingParticipant, sessionId));\n                  }\n                  break;\n                /**\n                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\n                 * Check the 'ParticipantId' to check whether the message is for the current user.\n                 */\n                case \"disconnectsession\":\n                  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                  const disconnectParticipant = {\n                    id: commandPayload.participantId\n                  };\n                  break;\n                case \"token\":\n                  const token = new Exports_js_3.CognitiveTokenAuthentication(() => {\n                    const authorizationToken = commandPayload.token;\n                    return Promise.resolve(authorizationToken);\n                  }, () => {\n                    const authorizationToken = commandPayload.token;\n                    return Promise.resolve(authorizationToken);\n                  });\n                  this.authentication = token;\n                  this.privConversationServiceConnector.onToken(token);\n                  break;\n                /**\n                 * Message not recognized.\n                 */\n                default:\n                  break;\n              }\n              break;\n            /**\n             * 'partial' (or 'hypothesis') represents a unfinalized speech message.\n             */\n            case \"partial\":\n            /**\n             * 'final' (or 'phrase') represents a finalized speech message.\n             */\n            case \"final\":\n              const speechPayload = Exports_js_4.SpeechResponsePayload.fromJSON(message.textBody);\n              const conversationResultReason = conversationMessageType === \"final\" ? Exports_js_2.ResultReason.TranslatedParticipantSpeech : Exports_js_2.ResultReason.TranslatingParticipantSpeech;\n              const speechResult = new Exports_js_2.ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, speechPayload.id, conversationResultReason, speechPayload.recognition, undefined, undefined, message.textBody, undefined);\n              if (speechPayload.isFinal) {\n                // check the length, sometimes empty finals are returned\n                if (speechResult.text !== undefined && speechResult.text.length > 0) {\n                  sendFinal = true;\n                } else if (speechPayload.id === this.privLastPartialUtteranceId) {\n                  // send final as normal. We had a non-empty partial for this same utterance\n                  // so sending the empty final is important\n                  sendFinal = true;\n                } else {\n                  // suppress unneeded final\n                }\n                if (sendFinal) {\n                  if (!!this.privConversationServiceConnector.translationReceived) {\n                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_js_1.ConversationTranslatorMessageTypes.final, speechResult, sessionId));\n                  }\n                }\n              } else if (speechResult.text !== undefined) {\n                this.privLastPartialUtteranceId = speechPayload.id;\n                if (!!this.privConversationServiceConnector.translationReceived) {\n                  this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_js_1.ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\n                }\n              }\n              break;\n            /**\n             * \"translated_message\" is a text message or instant message (IM).\n             */\n            case \"translated_message\":\n              const textPayload = Exports_js_4.TextResponsePayload.fromJSON(message.textBody);\n              // TODO: (Native parity) a result reason should be set based whether the participantId is ours or not\n              const textResult = new Exports_js_2.ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);\n              if (!!this.privConversationServiceConnector.translationReceived) {\n                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_js_1.ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\n              }\n              break;\n            default:\n              // ignore any unsupported message types\n              break;\n          }\n        } catch (e) {\n          // continue\n        }\n        return this.receiveConversationMessageOverride();\n      } catch (e) {\n        this.terminateMessageLoop = true;\n      }\n      return communicationCustodian.promise;\n    });\n  }\n  startMessageLoop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed()) {\n        return Promise.resolve();\n      }\n      this.terminateMessageLoop = false;\n      const messageRetrievalPromise = this.receiveConversationMessageOverride();\n      try {\n        const r = yield messageRetrievalPromise;\n        return r;\n      } catch (error) {\n        this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", Exports_js_2.CancellationReason.Error, Exports_js_2.CancellationErrorCode.RuntimeError, error);\n        return null;\n      }\n    });\n  }\n  // Takes an established websocket connection to the endpoint\n  configConnection() {\n    if (this.isDisposed()) {\n      return Promise.resolve(undefined);\n    }\n    if (this.privConnectionConfigPromise !== undefined) {\n      return this.privConnectionConfigPromise.then(connection => {\n        if (connection.state() === Exports_js_1.ConnectionState.Disconnected) {\n          this.privConnectionId = null;\n          this.privConnectionConfigPromise = undefined;\n          return this.configConnection();\n        }\n        return this.privConnectionConfigPromise;\n      }, () => {\n        this.privConnectionId = null;\n        this.privConnectionConfigPromise = undefined;\n        return this.configConnection();\n      });\n    }\n    if (this.terminateMessageLoop) {\n      return Promise.resolve(undefined);\n    }\n    this.privConnectionConfigPromise = this.connectImpl().then(connection => connection);\n    return this.privConnectionConfigPromise;\n  }\n  getTranslations(serviceResultTranslations) {\n    let translations;\n    if (undefined !== serviceResultTranslations) {\n      translations = new Exports_js_2.Translations();\n      for (const translation of serviceResultTranslations) {\n        translations.set(translation.lang, translation.translation);\n      }\n    }\n    return translations;\n  }\n}\nexports.ConversationServiceAdapter = ConversationServiceAdapter;\n\n//# sourceMappingURL=ConversationServiceAdapter.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}