{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TranslationServiceRecognizer = void 0;\nconst Exports_js_1 = require(\"../common/Exports.js\");\nconst Exports_js_2 = require(\"../sdk/Exports.js\");\nconst Exports_js_3 = require(\"./Exports.js\");\n// eslint-disable-next-line max-classes-per-file\nclass TranslationServiceRecognizer extends Exports_js_3.ConversationServiceRecognizer {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer);\n    this.privTranslationRecognizer = translationRecognizer;\n    this.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\n        this.privTranslationRecognizer.onConnection();\n      }\n    });\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const resultProps = new Exports_js_2.PropertyCollection();\n      let processed = yield this.processSpeechMessages(connectionMessage);\n      if (processed) {\n        return true;\n      }\n      const handleTranslationPhrase = translatedPhrase => __awaiter(this, void 0, void 0, function* () {\n        this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset + translatedPhrase.Duration);\n        if (translatedPhrase.RecognitionStatus === Exports_js_3.RecognitionStatus.Success) {\n          // OK, the recognition was successful. How'd the translation do?\n          const result = this.fireEventForResult(translatedPhrase, resultProps);\n          if (!!this.privTranslationRecognizer.recognized) {\n            try {\n              this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, result);\n              /* eslint-disable no-empty */\n            } catch (error) {\n              // Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n          // report result to promise.\n          if (!!this.privSuccessCallback) {\n            try {\n              this.privSuccessCallback(result.result);\n            } catch (e) {\n              if (!!this.privErrorCallback) {\n                this.privErrorCallback(e);\n              }\n            }\n            // Only invoke the call back once.\n            // and if it's successful don't invoke the\n            // error after that.\n            this.privSuccessCallback = undefined;\n            this.privErrorCallback = undefined;\n          }\n        } else {\n          const reason = Exports_js_3.EnumTranslation.implTranslateRecognitionResult(translatedPhrase.RecognitionStatus);\n          const result = new Exports_js_2.TranslationRecognitionResult(undefined, this.privRequestSession.requestId, reason, translatedPhrase.Text, translatedPhrase.Duration, this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset, translatedPhrase.Language, translatedPhrase.Confidence, undefined, connectionMessage.textBody, resultProps);\n          if (reason === Exports_js_2.ResultReason.Canceled) {\n            const cancelReason = Exports_js_3.EnumTranslation.implTranslateCancelResult(translatedPhrase.RecognitionStatus);\n            const cancellationErrorCode = Exports_js_3.EnumTranslation.implTranslateCancelErrorCode(translatedPhrase.RecognitionStatus);\n            yield this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_js_3.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));\n          } else {\n            if (!(this.privRequestSession.isSpeechEnded && reason === Exports_js_2.ResultReason.NoMatch && translatedPhrase.RecognitionStatus !== Exports_js_3.RecognitionStatus.InitialSilenceTimeout)) {\n              const ev = new Exports_js_2.TranslationRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n              if (!!this.privTranslationRecognizer.recognized) {\n                try {\n                  this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);\n                  /* eslint-disable no-empty */\n                } catch (error) {\n                  // Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n            }\n            // report result to promise.\n            if (!!this.privSuccessCallback) {\n              try {\n                this.privSuccessCallback(result);\n              } catch (e) {\n                if (!!this.privErrorCallback) {\n                  this.privErrorCallback(e);\n                }\n              }\n              // Only invoke the call back once.\n              // and if it's successful don't invoke the\n              // error after that.\n              this.privSuccessCallback = undefined;\n              this.privErrorCallback = undefined;\n            }\n          }\n          processed = true;\n        }\n      });\n      const handleTranslationHypothesis = (hypothesis, resultProperties) => {\n        const result = this.fireEventForResult(hypothesis, resultProperties);\n        this.privRequestSession.onHypothesis(this.privRequestSession.currentTurnAudioOffset + result.offset);\n        if (!!this.privTranslationRecognizer.recognizing) {\n          try {\n            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, result);\n            /* eslint-disable no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n      };\n      if (connectionMessage.messageType === Exports_js_1.MessageType.Text) {\n        resultProps.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n      }\n      switch (connectionMessage.path.toLowerCase()) {\n        case \"translation.hypothesis\":\n          handleTranslationHypothesis(Exports_js_3.TranslationHypothesis.fromJSON(connectionMessage.textBody), resultProps);\n          break;\n        case \"translation.response\":\n          const phrase = JSON.parse(connectionMessage.textBody);\n          if (!!phrase.SpeechPhrase) {\n            yield handleTranslationPhrase(Exports_js_3.TranslationPhrase.fromTranslationResponse(phrase));\n          } else {\n            const hypothesis = JSON.parse(connectionMessage.textBody);\n            if (!!hypothesis.SpeechHypothesis) {\n              handleTranslationHypothesis(Exports_js_3.TranslationHypothesis.fromTranslationResponse(hypothesis), resultProps);\n            }\n          }\n          break;\n        case \"translation.phrase\":\n          yield handleTranslationPhrase(Exports_js_3.TranslationPhrase.fromJSON(connectionMessage.textBody));\n          break;\n        case \"translation.synthesis\":\n          this.sendSynthesisAudio(connectionMessage.binaryBody, this.privRequestSession.sessionId);\n          processed = true;\n          break;\n        case \"audio.end\":\n        case \"translation.synthesis.end\":\n          const synthEnd = Exports_js_3.TranslationSynthesisEnd.fromJSON(connectionMessage.textBody);\n          switch (synthEnd.SynthesisStatus) {\n            case Exports_js_3.SynthesisStatus.Error:\n              if (!!this.privTranslationRecognizer.synthesizing) {\n                const result = new Exports_js_2.TranslationSynthesisResult(Exports_js_2.ResultReason.Canceled, undefined);\n                const retEvent = new Exports_js_2.TranslationSynthesisEventArgs(result, this.privRequestSession.sessionId);\n                try {\n                  this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);\n                  /* eslint-disable no-empty */\n                } catch (error) {\n                  // Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n              if (!!this.privTranslationRecognizer.canceled) {\n                // And raise a canceled event to send the rich(er) error message back.\n                const canceledResult = new Exports_js_2.TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, Exports_js_2.CancellationReason.Error, synthEnd.FailureReason, Exports_js_2.CancellationErrorCode.ServiceError, null);\n                try {\n                  this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, canceledResult);\n                  /* eslint-disable no-empty */\n                } catch (error) {\n                  // Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n              break;\n            case Exports_js_3.SynthesisStatus.Success:\n              this.sendSynthesisAudio(undefined, this.privRequestSession.sessionId);\n              break;\n            default:\n              break;\n          }\n          processed = true;\n          break;\n        default:\n          break;\n      }\n      return processed;\n    });\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    const properties = new Exports_js_2.PropertyCollection();\n    properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);\n    if (!!this.privTranslationRecognizer.canceled) {\n      const cancelEvent = new Exports_js_2.TranslationRecognitionCanceledEventArgs(sessionId, cancellationReason, error, errorCode, undefined);\n      try {\n        this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, cancelEvent);\n        /* eslint-disable no-empty */\n      } catch (_a) {}\n    }\n    if (!!this.privSuccessCallback) {\n      const result = new Exports_js_2.TranslationRecognitionResult(undefined,\n      // Translations\n      requestId, Exports_js_2.ResultReason.Canceled, undefined,\n      // Text\n      undefined,\n      // Druation\n      undefined,\n      // Offset\n      undefined,\n      // Language\n      undefined,\n      // LanguageDetectionConfidence\n      error, undefined,\n      // Json\n      properties);\n      try {\n        this.privSuccessCallback(result);\n        /* eslint-disable no-empty */\n        this.privSuccessCallback = undefined;\n      } catch (_b) {}\n    }\n  }\n  handleRecognizingCallback(result, duration, sessionId) {\n    try {\n      const ev = new Exports_js_2.TranslationRecognitionEventArgs(Exports_js_2.TranslationRecognitionResult.fromSpeechRecognitionResult(result), duration, sessionId);\n      this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, ev);\n      /* eslint-disable no-empty */\n    } catch (error) {\n      // Not going to let errors in the event handler\n      // trip things up.\n    }\n  }\n  handleRecognizedCallback(result, offset, sessionId) {\n    try {\n      const ev = new Exports_js_2.TranslationRecognitionEventArgs(Exports_js_2.TranslationRecognitionResult.fromSpeechRecognitionResult(result), offset, sessionId);\n      this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);\n    } catch (error) {\n      // Not going to let errors in the event handler\n      // trip things up.\n    }\n  }\n  fireEventForResult(serviceResult, properties) {\n    let translations;\n    if (undefined !== serviceResult.Translation.Translations) {\n      translations = new Exports_js_2.Translations();\n      for (const translation of serviceResult.Translation.Translations) {\n        translations.set(translation.Language, translation.Text || translation.DisplayText);\n      }\n    }\n    let resultReason;\n    let confidence;\n    if (serviceResult instanceof Exports_js_3.TranslationPhrase) {\n      if (!!serviceResult.Translation && serviceResult.Translation.TranslationStatus === Exports_js_1.TranslationStatus.Success) {\n        resultReason = Exports_js_2.ResultReason.TranslatedSpeech;\n      } else {\n        resultReason = Exports_js_2.ResultReason.RecognizedSpeech;\n      }\n      confidence = serviceResult.Confidence;\n    } else {\n      resultReason = Exports_js_2.ResultReason.TranslatingSpeech;\n    }\n    const language = serviceResult.Language;\n    const offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\n    const result = new Exports_js_2.TranslationRecognitionResult(translations, this.privRequestSession.requestId, resultReason, serviceResult.Text, serviceResult.Duration, offset, language, confidence, serviceResult.Translation.FailureReason, JSON.stringify(serviceResult), properties);\n    const ev = new Exports_js_2.TranslationRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\n    return ev;\n  }\n  sendSynthesisAudio(audio, sessionId) {\n    const reason = undefined === audio ? Exports_js_2.ResultReason.SynthesizingAudioCompleted : Exports_js_2.ResultReason.SynthesizingAudio;\n    const result = new Exports_js_2.TranslationSynthesisResult(reason, audio);\n    const retEvent = new Exports_js_2.TranslationSynthesisEventArgs(result, sessionId);\n    if (!!this.privTranslationRecognizer.synthesizing) {\n      try {\n        this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);\n        /* eslint-disable no-empty */\n      } catch (error) {\n        // Not going to let errors in the event handler\n        // trip things up.\n      }\n    }\n  }\n}\nexports.TranslationServiceRecognizer = TranslationServiceRecognizer;\n\n//# sourceMappingURL=TranslationServiceRecognizer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}