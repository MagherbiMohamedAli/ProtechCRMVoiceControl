{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TranscriberRecognizer = void 0;\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nconst Exports_js_1 = require(\"../../common/Exports.js\");\nconst Contracts_js_1 = require(\"../../sdk/Contracts.js\");\nconst Exports_js_2 = require(\"../../sdk/Exports.js\");\nconst Exports_js_3 = require(\"../Exports.js\");\nclass TranscriberRecognizer extends Exports_js_2.Recognizer {\n  /**\n   * TranscriberRecognizer constructor.\n   * @constructor\n   * @param {SpeechTranslationConfig} speechTranslationConfig - Non-audio configuration associated with the recognizer\n   * @param {AudioConfig} audioConfig - An audio configuration associated with the recognizer\n   */\n  constructor(speechTranslationConfig, audioConfig) {\n    const speechTranslationConfigImpl = speechTranslationConfig;\n    Contracts_js_1.Contracts.throwIfNull(speechTranslationConfigImpl, \"speechTranslationConfig\");\n    const audioConfigImpl = audioConfig;\n    Contracts_js_1.Contracts.throwIfNull(audioConfigImpl, \"audioConfigImpl\");\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(speechTranslationConfigImpl.speechRecognitionLanguage, Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage]);\n    super(audioConfig, speechTranslationConfigImpl.properties, new Exports_js_3.TranscriberConnectionFactory());\n    this.privDisposedRecognizer = false;\n    this.isMeetingRecognizer = false;\n  }\n  get speechRecognitionLanguage() {\n    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);\n    return this.properties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage);\n  }\n  get properties() {\n    return this.privProperties;\n  }\n  get authorizationToken() {\n    return this.properties.getProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token);\n  }\n  set authorizationToken(token) {\n    Contracts_js_1.Contracts.throwIfNullOrWhitespace(token, \"token\");\n    this.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, token);\n  }\n  set conversation(c) {\n    Contracts_js_1.Contracts.throwIfNullOrUndefined(c, \"Conversation\");\n    this.isMeetingRecognizer = false;\n    this.privConversation = c;\n  }\n  getConversationInfo() {\n    Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation, \"Conversation\");\n    return this.privConversation.conversationInfo;\n  }\n  set meeting(m) {\n    Contracts_js_1.Contracts.throwIfNullOrUndefined(m, \"Meeting\");\n    this.isMeetingRecognizer = true;\n    this.privMeeting = m;\n  }\n  getMeetingInfo() {\n    Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privMeeting, \"Meeting\");\n    return this.privMeeting.meetingInfo;\n  }\n  IsMeetingRecognizer() {\n    return this.isMeetingRecognizer;\n  }\n  startContinuousRecognitionAsync(cb, err) {\n    Exports_js_1.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_3.RecognitionMode.Conversation), cb, err);\n  }\n  stopContinuousRecognitionAsync(cb, err) {\n    Exports_js_1.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privDisposedRecognizer) {\n        yield this.dispose(true);\n      }\n    });\n  }\n  // Push async join/leave conversation message via serviceRecognizer\n  pushConversationEvent(conversationInfo, command) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const reco = this.privReco;\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(reco, \"serviceRecognizer\");\n      yield reco.sendSpeechEventAsync(conversationInfo, command);\n    });\n  }\n  // Push async join/leave meeting message via serviceRecognizer\n  pushMeetingEvent(meetingInfo, command) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const reco = this.privReco;\n      Contracts_js_1.Contracts.throwIfNullOrUndefined(reco, \"serviceRecognizer\");\n      yield reco.sendMeetingSpeechEventAsync(meetingInfo, command);\n    });\n  }\n  enforceAudioGating() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const audioConfigImpl = this.audioConfig;\n      const format = yield audioConfigImpl.format;\n      const channels = format.channels;\n      if (channels === 1) {\n        if (this.properties.getProperty(\"f0f5debc-f8c9-4892-ac4b-90a7ab359fd2\", \"false\").toLowerCase() !== \"true\") {\n          throw new Error(\"Single channel audio configuration for MeetingTranscriber is currently under private preview, please contact diarizationrequest@microsoft.com for more details\");\n        }\n      } else if (channels !== 8) {\n        throw new Error(`Unsupported audio configuration: Detected ${channels}-channel audio`);\n      }\n      return;\n    });\n  }\n  connectMeetingCallbacks(transcriber) {\n    this.isMeetingRecognizer = true;\n    this.canceled = (s, e) => {\n      if (!!transcriber.canceled) {\n        transcriber.canceled(transcriber, e);\n      }\n    };\n    this.recognizing = (s, e) => {\n      if (!!transcriber.transcribing) {\n        transcriber.transcribing(transcriber, e);\n      }\n    };\n    this.recognized = (s, e) => {\n      if (!!transcriber.transcribed) {\n        transcriber.transcribed(transcriber, e);\n      }\n    };\n    this.sessionStarted = (s, e) => {\n      if (!!transcriber.sessionStarted) {\n        transcriber.sessionStarted(transcriber, e);\n      }\n    };\n    this.sessionStopped = (s, e) => {\n      if (!!transcriber.sessionStopped) {\n        transcriber.sessionStopped(transcriber, e);\n      }\n    };\n  }\n  disconnectCallbacks() {\n    this.canceled = undefined;\n    this.recognizing = undefined;\n    this.recognized = undefined;\n    this.sessionStarted = undefined;\n    this.sessionStopped = undefined;\n  }\n  /**\n   * Disposes any resources held by the object.\n   * @member ConversationTranscriber.prototype.dispose\n   * @function\n   * @public\n   * @param {boolean} disposing - true if disposing the object.\n   */\n  dispose(disposing) {\n    const _super = Object.create(null, {\n      dispose: {\n        get: () => super.dispose\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privDisposedRecognizer) {\n        return;\n      }\n      if (disposing) {\n        this.privDisposedRecognizer = true;\n        yield this.implRecognizerStop();\n      }\n      yield _super.dispose.call(this, disposing);\n    });\n  }\n  createRecognizerConfig(speechConfig) {\n    return new Exports_js_3.RecognizerConfig(speechConfig, this.properties);\n  }\n  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {\n    const configImpl = audioConfig;\n    return new Exports_js_3.TranscriptionServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);\n  }\n}\nexports.TranscriberRecognizer = TranscriberRecognizer;\n\n//# sourceMappingURL=TranscriberRecognizer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}