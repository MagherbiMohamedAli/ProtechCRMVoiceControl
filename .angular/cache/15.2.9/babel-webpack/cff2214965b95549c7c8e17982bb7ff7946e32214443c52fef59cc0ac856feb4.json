{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SpeechSynthesizer = void 0;\nconst Exports_js_1 = require(\"../common.speech/Exports.js\");\nconst Exports_js_2 = require(\"../common/Exports.js\");\nconst AudioFileWriter_js_1 = require(\"./Audio/AudioFileWriter.js\");\nconst AudioOutputFormat_js_1 = require(\"./Audio/AudioOutputFormat.js\");\nconst AudioOutputStream_js_1 = require(\"./Audio/AudioOutputStream.js\");\nconst Contracts_js_1 = require(\"./Contracts.js\");\nconst Exports_js_3 = require(\"./Exports.js\");\nconst Synthesizer_js_1 = require(\"./Synthesizer.js\");\n/**\n * Defines the class SpeechSynthesizer for text to speech.\n * Updated in version 1.16.0\n * @class SpeechSynthesizer\n */\nclass SpeechSynthesizer extends Exports_js_3.Synthesizer {\n  /**\n   * SpeechSynthesizer constructor.\n   * @constructor\n   * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer.\n   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer.\n   */\n  constructor(speechConfig, audioConfig) {\n    super(speechConfig);\n    if (audioConfig !== null) {\n      if (audioConfig === undefined) {\n        this.audioConfig = typeof window === \"undefined\" ? undefined : Exports_js_3.AudioConfig.fromDefaultSpeakerOutput();\n      } else {\n        this.audioConfig = audioConfig;\n      }\n    }\n    this.privConnectionFactory = new Exports_js_1.SpeechSynthesisConnectionFactory();\n    this.implCommonSynthesizeSetup();\n  }\n  /**\n   * SpeechSynthesizer constructor.\n   * @constructor\n   * @param {SpeechConfig} speechConfig - an set of initial properties for this synthesizer\n   * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the synthesizer\n   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer\n   */\n  static FromConfig(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {\n    const speechConfigImpl = speechConfig;\n    autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);\n    return new SpeechSynthesizer(speechConfig, audioConfig);\n  }\n  /**\n   * Executes speech synthesis on plain text.\n   * The task returns the synthesis result.\n   * @member SpeechSynthesizer.prototype.speakTextAsync\n   * @function\n   * @public\n   * @param text - Text to be synthesized.\n   * @param cb - Callback that received the SpeechSynthesisResult.\n   * @param err - Callback invoked in case of an error.\n   * @param stream - AudioOutputStream to receive the synthesized audio.\n   */\n  speakTextAsync(text, cb, err, stream) {\n    this.speakImpl(text, false, cb, err, stream);\n  }\n  /**\n   * Executes speech synthesis on SSML.\n   * The task returns the synthesis result.\n   * @member SpeechSynthesizer.prototype.speakSsmlAsync\n   * @function\n   * @public\n   * @param ssml - SSML to be synthesized.\n   * @param cb - Callback that received the SpeechSynthesisResult.\n   * @param err - Callback invoked in case of an error.\n   * @param stream - AudioOutputStream to receive the synthesized audio.\n   */\n  speakSsmlAsync(ssml, cb, err, stream) {\n    this.speakImpl(ssml, true, cb, err, stream);\n  }\n  /**\n   * Get list of synthesis voices available.\n   * The task returns the synthesis voice result.\n   * @member SpeechSynthesizer.prototype.getVoicesAsync\n   * @function\n   * @async\n   * @public\n   * @param locale - Locale of voices in BCP-47 format; if left empty, get all available voices.\n   * @return {Promise<SynthesisVoicesResult>} - Promise of a SynthesisVoicesResult.\n   */\n  getVoicesAsync(locale = \"\") {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.getVoices(locale);\n    });\n  }\n  /**\n   * Dispose of associated resources.\n   * @member SpeechSynthesizer.prototype.close\n   * @function\n   * @public\n   */\n  close(cb, err) {\n    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposed);\n    Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb, err);\n  }\n  /**\n   * @Internal\n   * Do not use externally, object returned will change without warning or notice.\n   */\n  get internalData() {\n    return this.privAdapter;\n  }\n  //\n  // ################################################################################################################\n  // IMPLEMENTATION.\n  // ################################################################################################################\n  //\n  // Creates the synthesis adapter\n  createSynthesisAdapter(authentication, connectionFactory, synthesizerConfig) {\n    return new Exports_js_1.SpeechSynthesisAdapter(authentication, connectionFactory, synthesizerConfig, this, this.audioConfig);\n  }\n  createRestSynthesisAdapter(authentication, synthesizerConfig) {\n    return new Exports_js_1.SynthesisRestAdapter(synthesizerConfig, authentication);\n  }\n  implCommonSynthesizeSetup() {\n    super.implCommonSynthesizeSetup();\n    this.privAdapter.audioOutputFormat = AudioOutputFormat_js_1.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(Exports_js_3.SpeechSynthesisOutputFormat[this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)]);\n  }\n  speakImpl(text, IsSsml, cb, err, dataStream) {\n    try {\n      Contracts_js_1.Contracts.throwIfDisposed(this.privDisposed);\n      const requestId = Exports_js_2.createNoDashGuid();\n      let audioDestination;\n      if (dataStream instanceof Exports_js_3.PushAudioOutputStreamCallback) {\n        audioDestination = new AudioOutputStream_js_1.PushAudioOutputStreamImpl(dataStream);\n      } else if (dataStream instanceof Exports_js_3.PullAudioOutputStream) {\n        audioDestination = dataStream;\n      } else if (dataStream !== undefined) {\n        audioDestination = new AudioFileWriter_js_1.AudioFileWriter(dataStream);\n      } else {\n        audioDestination = undefined;\n      }\n      this.synthesisRequestQueue.enqueue(new Synthesizer_js_1.SynthesisRequest(requestId, text, IsSsml, e => {\n        this.privSynthesizing = false;\n        if (!!cb) {\n          try {\n            cb(e);\n          } catch (e) {\n            if (!!err) {\n              err(e);\n            }\n          }\n        }\n        cb = undefined;\n        /* eslint-disable no-empty */\n        this.adapterSpeak().catch(() => {});\n      }, e => {\n        if (!!err) {\n          err(e);\n        }\n      }, audioDestination));\n      /* eslint-disable no-empty-function */\n      this.adapterSpeak().catch(() => {});\n    } catch (error) {\n      if (!!err) {\n        if (error instanceof Error) {\n          const typedError = error;\n          err(typedError.name + \": \" + typedError.message);\n        } else {\n          err(error);\n        }\n      }\n      // Destroy the synthesizer.\n      /* eslint-disable no-empty */\n      this.dispose(true).catch(() => {});\n    }\n  }\n  getVoices(locale) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const requestId = Exports_js_2.createNoDashGuid();\n      const response = yield this.privRestAdapter.getVoicesList(requestId);\n      if (response.ok && Array.isArray(response.json)) {\n        let json = response.json;\n        if (!!locale && locale.length > 0) {\n          json = json.filter(item => !!item.Locale && item.Locale.toLowerCase() === locale.toLowerCase());\n        }\n        return new Exports_js_3.SynthesisVoicesResult(requestId, json, undefined);\n      } else {\n        return new Exports_js_3.SynthesisVoicesResult(requestId, undefined, `Error: ${response.status}: ${response.statusText}`);\n      }\n    });\n  }\n}\nexports.SpeechSynthesizer = SpeechSynthesizer;\n\n//# sourceMappingURL=SpeechSynthesizer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}