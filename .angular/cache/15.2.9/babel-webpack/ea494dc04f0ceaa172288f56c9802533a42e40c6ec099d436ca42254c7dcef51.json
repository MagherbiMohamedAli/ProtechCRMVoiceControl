{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TranscriptionServiceRecognizer = void 0;\nconst Exports_js_1 = require(\"../common/Exports.js\");\nconst Exports_js_2 = require(\"../sdk/Exports.js\");\nconst Exports_js_3 = require(\"./Exports.js\");\nconst SpeechConnectionMessage_Internal_js_1 = require(\"./SpeechConnectionMessage.Internal.js\");\n// eslint-disable-next-line max-classes-per-file\nclass TranscriptionServiceRecognizer extends Exports_js_3.ConversationServiceRecognizer {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, transcriber) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, transcriber);\n    this.privTranscriberRecognizer = transcriber;\n    this.sendPrePayloadJSONOverride = connection => this.sendTranscriptionStartJSON(connection);\n    if (this.privRecognizerConfig.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps) === \"true\") {\n      this.privSpeechContext.setWordLevelTimings();\n    }\n  }\n  sendSpeechEventAsync(info, command) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privRequestSession.isRecognizing) {\n        const connection = yield this.fetchConnection();\n        yield this.sendSpeechEvent(connection, this.createSpeechEventPayload(info, command));\n      }\n    });\n  }\n  sendMeetingSpeechEventAsync(info, command) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privRequestSession.isRecognizing) {\n        const connection = yield this.fetchConnection();\n        yield this.sendSpeechEvent(connection, this.createMeetingSpeechEventPayload(info, command));\n      }\n    });\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    return this.processSpeechMessages(connectionMessage);\n  }\n  handleRecognizedCallback(result, offset, sessionId) {\n    try {\n      const event = new Exports_js_2.SpeechRecognitionEventArgs(result, offset, sessionId);\n      this.privTranscriberRecognizer.recognized(this.privTranscriberRecognizer, event);\n      if (!!this.privSuccessCallback) {\n        try {\n          this.privSuccessCallback(result);\n        } catch (e) {\n          if (!!this.privErrorCallback) {\n            this.privErrorCallback(e);\n          }\n        }\n        // Only invoke the call back once.\n        // and if it's successful don't invoke the\n        // error after that.\n        this.privSuccessCallback = undefined;\n        this.privErrorCallback = undefined;\n      }\n      /* eslint-disable no-empty */\n    } catch (error) {\n      // Not going to let errors in the event handler\n      // trip things up.\n    }\n  }\n  handleRecognizingCallback(result, duration, sessionId) {\n    try {\n      const ev = new Exports_js_2.SpeechRecognitionEventArgs(result, duration, sessionId);\n      this.privTranscriberRecognizer.recognizing(this.privTranscriberRecognizer, ev);\n      /* eslint-disable no-empty */\n    } catch (error) {\n      // Not going to let errors in the event handler\n      // trip things up.\n    }\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    const properties = new Exports_js_2.PropertyCollection();\n    properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);\n    if (this.privTranscriberRecognizer.IsMeetingRecognizer()) {\n      if (!!this.privTranscriberRecognizer.canceled) {\n        const cancelEvent = new Exports_js_2.MeetingTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n        try {\n          this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, cancelEvent);\n          /* eslint-disable no-empty */\n        } catch (_a) {}\n      }\n    } else {\n      if (!!this.privTranscriberRecognizer.canceled) {\n        const cancelEvent = new Exports_js_2.ConversationTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n        try {\n          this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, cancelEvent);\n          /* eslint-disable no-empty */\n        } catch (_b) {}\n      }\n    }\n    if (!!this.privSuccessCallback) {\n      const result = new Exports_js_2.SpeechRecognitionResult(requestId, Exports_js_2.ResultReason.Canceled, undefined,\n      // Text\n      undefined,\n      // Duration\n      undefined,\n      // Offset\n      undefined,\n      // Language\n      undefined,\n      // Language Detection Confidence\n      undefined,\n      // Speaker Id\n      error, undefined,\n      // Json\n      properties);\n      try {\n        this.privSuccessCallback(result);\n        this.privSuccessCallback = undefined;\n        /* eslint-disable no-empty */\n      } catch (_c) {}\n    }\n  }\n  // Encapsulated for derived service recognizers that need to send additional JSON\n  sendTranscriptionStartJSON(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.sendSpeechContext(connection, true);\n      if (this.privTranscriberRecognizer.IsMeetingRecognizer()) {\n        const info = this.privTranscriberRecognizer.getMeetingInfo();\n        const payload = this.createMeetingSpeechEventPayload(info, \"start\");\n        yield this.sendSpeechEvent(connection, payload);\n      } else {\n        const info = this.privTranscriberRecognizer.getConversationInfo();\n        const payload = this.createSpeechEventPayload(info, \"start\");\n        yield this.sendSpeechEvent(connection, payload);\n      }\n      yield this.sendWaveHeader(connection);\n      return;\n    });\n  }\n  sendSpeechEvent(connection, payload) {\n    const speechEventJson = JSON.stringify(payload);\n    if (speechEventJson) {\n      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_1.MessageType.Text, \"speech.event\", this.privRequestSession.requestId, \"application/json\", speechEventJson));\n    }\n    return;\n  }\n  createSpeechEventPayload(info, command) {\n    const eventDict = {\n      id: \"meeting\",\n      name: command,\n      meeting: info.conversationProperties\n    };\n    eventDict.meeting.id = info.id;\n    eventDict.meeting.attendees = info.participants;\n    return eventDict;\n  }\n  createMeetingSpeechEventPayload(info, command) {\n    const eventDict = {\n      id: \"meeting\",\n      name: command,\n      meeting: info.meetingProperties\n    };\n    eventDict.meeting.id = info.id;\n    eventDict.meeting.attendees = info.participants;\n    return eventDict;\n  }\n}\nexports.TranscriptionServiceRecognizer = TranscriptionServiceRecognizer;\n\n//# sourceMappingURL=TranscriptionServiceRecognizer.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}