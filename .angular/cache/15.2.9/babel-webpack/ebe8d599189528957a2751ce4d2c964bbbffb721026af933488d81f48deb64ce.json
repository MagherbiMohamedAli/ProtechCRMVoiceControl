{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SynthesisAdapterBase = void 0;\nconst Exports_js_1 = require(\"../common/Exports.js\");\nconst Exports_js_2 = require(\"../sdk/Exports.js\");\nconst Exports_js_3 = require(\"./Exports.js\");\nconst SpeechConnectionMessage_Internal_js_1 = require(\"./SpeechConnectionMessage.Internal.js\");\nclass SynthesisAdapterBase {\n  constructor(authentication, connectionFactory, synthesizerConfig, audioDestination) {\n    this.speakOverride = undefined;\n    this.receiveMessageOverride = undefined;\n    this.connectImplOverride = undefined;\n    this.configConnectionOverride = undefined;\n    // A promise for a configured connection.\n    // Do not consume directly, call fetchConnection instead.\n    this.privConnectionConfigurationPromise = undefined;\n    if (!authentication) {\n      throw new Exports_js_1.ArgumentNullError(\"authentication\");\n    }\n    if (!connectionFactory) {\n      throw new Exports_js_1.ArgumentNullError(\"connectionFactory\");\n    }\n    if (!synthesizerConfig) {\n      throw new Exports_js_1.ArgumentNullError(\"synthesizerConfig\");\n    }\n    this.privAuthentication = authentication;\n    this.privConnectionFactory = connectionFactory;\n    this.privSynthesizerConfig = synthesizerConfig;\n    this.privIsDisposed = false;\n    this.privSessionAudioDestination = audioDestination;\n    this.privSynthesisTurn = new Exports_js_3.SynthesisTurn();\n    this.privConnectionEvents = new Exports_js_1.EventSource();\n    this.privServiceEvents = new Exports_js_1.EventSource();\n    this.privSynthesisContext = new Exports_js_3.SynthesisContext();\n    this.privAgentConfig = new Exports_js_3.AgentConfig();\n    this.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        const connectionClosedEvent = connectionEvent;\n        if (connectionClosedEvent.statusCode !== 1000) {\n          this.cancelSynthesisLocal(Exports_js_2.CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? Exports_js_2.CancellationErrorCode.BadRequestParameters : Exports_js_2.CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);\n        }\n      }\n    });\n  }\n  get synthesisContext() {\n    return this.privSynthesisContext;\n  }\n  get agentConfig() {\n    return this.privAgentConfig;\n  }\n  get connectionEvents() {\n    return this.privConnectionEvents;\n  }\n  get serviceEvents() {\n    return this.privServiceEvents;\n  }\n  set activityTemplate(messagePayload) {\n    this.privActivityTemplate = messagePayload;\n  }\n  get activityTemplate() {\n    return this.privActivityTemplate;\n  }\n  set audioOutputFormat(format) {\n    this.privAudioOutputFormat = format;\n    this.privSynthesisTurn.audioOutputFormat = format;\n    if (this.privSessionAudioDestination !== undefined) {\n      this.privSessionAudioDestination.format = format;\n    }\n    if (this.synthesisContext !== undefined) {\n      this.synthesisContext.audioOutputFormat = format;\n    }\n  }\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n  dispose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privIsDisposed = true;\n      if (this.privSessionAudioDestination !== undefined) {\n        this.privSessionAudioDestination.close();\n      }\n      if (this.privConnectionConfigurationPromise !== undefined) {\n        const connection = yield this.privConnectionConfigurationPromise;\n        yield connection.dispose(reason);\n      }\n    });\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connectImpl();\n    });\n  }\n  sendNetworkMessage(path, payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const type = typeof payload === \"string\" ? Exports_js_1.MessageType.Text : Exports_js_1.MessageType.Binary;\n      const contentType = typeof payload === \"string\" ? \"application/json\" : \"\";\n      const connection = yield this.fetchConnection();\n      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\n    });\n  }\n  Speak(text, isSSML, requestId, successCallback, errorCallBack, audioDestination) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let ssml;\n      if (isSSML) {\n        ssml = text;\n      } else {\n        ssml = this.privSynthesizer.buildSsml(text);\n      }\n      if (this.speakOverride !== undefined) {\n        return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\n      }\n      this.privSuccessCallback = successCallback;\n      this.privErrorCallback = errorCallBack;\n      this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\n      try {\n        yield this.connectImpl();\n        const connection = yield this.fetchConnection();\n        yield this.sendSynthesisContext(connection);\n        yield this.sendSsmlMessage(connection, ssml, requestId);\n        this.onSynthesisStarted(requestId);\n        void this.receiveMessage();\n      } catch (e) {\n        this.cancelSynthesisLocal(Exports_js_2.CancellationReason.Error, Exports_js_2.CancellationErrorCode.ConnectionFailure, e);\n        return Promise.reject(e);\n      }\n    });\n  }\n  stopSpeaking() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connectImpl();\n      const connection = yield this.fetchConnection();\n      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_1.MessageType.Text, \"synthesis.control\", this.privSynthesisTurn.requestId, \"application/json\", JSON.stringify({\n        action: \"stop\"\n      })));\n    });\n  }\n  // Cancels synthesis.\n  cancelSynthesis(requestId, _cancellationReason, errorCode, error) {\n    const properties = new Exports_js_2.PropertyCollection();\n    properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);\n    const result = new Exports_js_2.SpeechSynthesisResult(requestId, Exports_js_2.ResultReason.Canceled, undefined, error, properties);\n    this.onSynthesisCancelled(result);\n    if (!!this.privSuccessCallback) {\n      try {\n        this.privSuccessCallback(result);\n        /* eslint-disable no-empty */\n      } catch (_a) {}\n    }\n  }\n  // Cancels synthesis.\n  cancelSynthesisLocal(cancellationReason, errorCode, error) {\n    if (!!this.privSynthesisTurn.isSynthesizing) {\n      this.privSynthesisTurn.onStopSynthesizing();\n      this.cancelSynthesis(this.privSynthesisTurn.requestId, cancellationReason, errorCode, error);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  processTypeSpecificMessages(_connectionMessage) {\n    return true;\n  }\n  receiveMessage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n        if (this.receiveMessageOverride !== undefined) {\n          return this.receiveMessageOverride();\n        }\n        if (this.privIsDisposed) {\n          // We're done.\n          return;\n        }\n        // indicates we are draining the queue and it came with no message;\n        if (!message) {\n          if (!this.privSynthesisTurn.isSynthesizing) {\n            return;\n          } else {\n            return this.receiveMessage();\n          }\n        }\n        const connectionMessage = SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage.fromConnectionMessage(message);\n        if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\n          switch (connectionMessage.path.toLowerCase()) {\n            case \"turn.start\":\n              this.privSynthesisTurn.onServiceTurnStartResponse(connectionMessage.textBody);\n              break;\n            case \"response\":\n              this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\n              break;\n            case \"audio\":\n              if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase() && !!connectionMessage.binaryBody) {\n                this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\n                this.onSynthesizing(connectionMessage.binaryBody);\n                if (this.privSessionAudioDestination !== undefined) {\n                  this.privSessionAudioDestination.write(connectionMessage.binaryBody);\n                }\n              }\n              break;\n            case \"audio.metadata\":\n              const metadataList = Exports_js_3.SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\n              for (const metadata of metadataList) {\n                switch (metadata.Type) {\n                  case Exports_js_3.MetadataType.WordBoundary:\n                  case Exports_js_3.MetadataType.SentenceBoundary:\n                    this.privSynthesisTurn.onTextBoundaryEvent(metadata);\n                    const wordBoundaryEventArgs = new Exports_js_2.SpeechSynthesisWordBoundaryEventArgs(metadata.Data.Offset, metadata.Data.Duration, metadata.Data.text.Text, metadata.Data.text.Length, metadata.Type === Exports_js_3.MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, metadata.Data.text.BoundaryType);\n                    this.onWordBoundary(wordBoundaryEventArgs);\n                    break;\n                  case Exports_js_3.MetadataType.Bookmark:\n                    const bookmarkEventArgs = new Exports_js_2.SpeechSynthesisBookmarkEventArgs(metadata.Data.Offset, metadata.Data.Bookmark);\n                    this.onBookmarkReached(bookmarkEventArgs);\n                    break;\n                  case Exports_js_3.MetadataType.Viseme:\n                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\n                    if (metadata.Data.IsLastAnimation) {\n                      const visemeEventArgs = new Exports_js_2.SpeechSynthesisVisemeEventArgs(metadata.Data.Offset, metadata.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());\n                      this.onVisemeReceived(visemeEventArgs);\n                    }\n                    break;\n                  case Exports_js_3.MetadataType.AvatarSignal:\n                    this.onAvatarEvent(metadata);\n                    break;\n                  case Exports_js_3.MetadataType.SessionEnd:\n                    this.privSynthesisTurn.onSessionEnd(metadata);\n                    break;\n                }\n              }\n              break;\n            case \"turn.end\":\n              this.privSynthesisTurn.onServiceTurnEndResponse();\n              let result;\n              try {\n                result = yield this.privSynthesisTurn.constructSynthesisResult();\n                if (!!this.privSuccessCallback) {\n                  this.privSuccessCallback(result);\n                }\n              } catch (error) {\n                if (!!this.privErrorCallback) {\n                  this.privErrorCallback(error);\n                }\n              }\n              this.onSynthesisCompleted(result);\n              break;\n            default:\n              if (!this.processTypeSpecificMessages(connectionMessage)) {\n                // here are some messages that the derived class has not processed, dispatch them to connect class\n                if (!!this.privServiceEvents) {\n                  this.serviceEvents.onEvent(new Exports_js_1.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                }\n              }\n          }\n        }\n        return this.receiveMessage();\n      } catch (e) {\n        // TODO: What goes here?\n      }\n    });\n  }\n  sendSynthesisContext(connection) {\n    this.setSynthesisContextSynthesisSection();\n    const synthesisContextJson = this.synthesisContext.toJSON();\n    if (synthesisContextJson) {\n      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_1.MessageType.Text, \"synthesis.context\", this.privSynthesisTurn.requestId, \"application/json\", synthesisContextJson));\n    }\n    return;\n  }\n  setSpeechConfigSynthesisSection() {\n    return;\n  }\n  connectImpl(isUnAuthorized = false) {\n    if (this.privConnectionPromise != null) {\n      return this.privConnectionPromise.then(connection => {\n        if (connection.state() === Exports_js_1.ConnectionState.Disconnected) {\n          this.privConnectionId = null;\n          this.privConnectionPromise = null;\n          return this.connectImpl();\n        }\n        return this.privConnectionPromise;\n      }, () => {\n        this.privConnectionId = null;\n        this.privConnectionPromise = null;\n        return this.connectImpl();\n      });\n    }\n    this.privAuthFetchEventId = Exports_js_1.createNoDashGuid();\n    this.privConnectionId = Exports_js_1.createNoDashGuid();\n    this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);\n    const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n    this.privConnectionPromise = authPromise.then(result => __awaiter(this, void 0, void 0, function* () {\n      this.privSynthesisTurn.onAuthCompleted(false);\n      const connection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\n      // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n      // it'll stop sending events.\n      connection.events.attach(event => {\n        this.connectionEvents.onEvent(event);\n      });\n      const response = yield connection.open();\n      if (response.statusCode === 200) {\n        this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n        return Promise.resolve(connection);\n      } else if (response.statusCode === 403 && !isUnAuthorized) {\n        return this.connectImpl(true);\n      } else {\n        this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n        return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\n      }\n    }), error => {\n      this.privSynthesisTurn.onAuthCompleted(true);\n      throw new Error(error);\n    });\n    // Attach an empty handler to allow the promise to run in the background while\n    // other startup events happen. It'll eventually be awaited on.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    this.privConnectionPromise.catch(() => {});\n    return this.privConnectionPromise;\n  }\n  sendSpeechServiceConfig(connection, SpeechServiceConfigJson) {\n    if (SpeechServiceConfigJson) {\n      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_1.MessageType.Text, \"speech.config\", this.privSynthesisTurn.requestId, \"application/json\", SpeechServiceConfigJson));\n    }\n  }\n  sendSsmlMessage(connection, ssml, requestId) {\n    return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_1.MessageType.Text, \"ssml\", requestId, \"application/ssml+xml\", ssml));\n  }\n  fetchConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privConnectionConfigurationPromise !== undefined) {\n        return this.privConnectionConfigurationPromise.then(connection => {\n          if (connection.state() === Exports_js_1.ConnectionState.Disconnected) {\n            this.privConnectionId = null;\n            this.privConnectionConfigurationPromise = undefined;\n            return this.fetchConnection();\n          }\n          return this.privConnectionConfigurationPromise;\n        }, () => {\n          this.privConnectionId = null;\n          this.privConnectionConfigurationPromise = undefined;\n          return this.fetchConnection();\n        });\n      }\n      this.privConnectionConfigurationPromise = this.configureConnection();\n      return yield this.privConnectionConfigurationPromise;\n    });\n  }\n  // Takes an established websocket connection to the endpoint and sends speech configuration information.\n  configureConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.connectImpl();\n      if (this.configConnectionOverride !== undefined) {\n        return this.configConnectionOverride(connection);\n      }\n      this.setSpeechConfigSynthesisSection();\n      yield this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\n      return connection;\n    });\n  }\n  onAvatarEvent(_metadata) {\n    return;\n  }\n  onSynthesisStarted(_requestId) {\n    return;\n  }\n  onSynthesizing(_audio) {\n    return;\n  }\n  onSynthesisCancelled(_result) {\n    return;\n  }\n  onSynthesisCompleted(_result) {\n    return;\n  }\n  onWordBoundary(_wordBoundaryEventArgs) {\n    return;\n  }\n  onVisemeReceived(_visemeEventArgs) {\n    return;\n  }\n  onBookmarkReached(_bookmarkEventArgs) {\n    return;\n  }\n}\nexports.SynthesisAdapterBase = SynthesisAdapterBase;\nSynthesisAdapterBase.telemetryDataEnabled = true;\n\n//# sourceMappingURL=SynthesisAdapterBase.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}