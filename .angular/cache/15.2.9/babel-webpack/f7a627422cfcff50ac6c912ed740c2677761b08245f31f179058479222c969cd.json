{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SpeakerAudioDestination = void 0;\nconst Exports_js_1 = require(\"../../common/Exports.js\");\nconst AudioOutputStream_js_1 = require(\"./AudioOutputStream.js\");\nconst AudioStreamFormat_js_1 = require(\"./AudioStreamFormat.js\");\nconst MediaDurationPlaceholderSeconds = 60 * 30;\nconst AudioFormatToMimeType = {\n  [AudioStreamFormat_js_1.AudioFormatTag.PCM]: \"audio/wav\",\n  [AudioStreamFormat_js_1.AudioFormatTag.MuLaw]: \"audio/x-wav\",\n  [AudioStreamFormat_js_1.AudioFormatTag.MP3]: \"audio/mpeg\",\n  [AudioStreamFormat_js_1.AudioFormatTag.OGG_OPUS]: \"audio/ogg\",\n  [AudioStreamFormat_js_1.AudioFormatTag.WEBM_OPUS]: \"audio/webm; codecs=opus\",\n  [AudioStreamFormat_js_1.AudioFormatTag.ALaw]: \"audio/x-wav\",\n  [AudioStreamFormat_js_1.AudioFormatTag.FLAC]: \"audio/flac\"\n};\n/**\n * Represents the speaker playback audio destination, which only works in browser.\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\n * @class SpeakerAudioDestination\n * Updated in version 1.17.0\n */\nclass SpeakerAudioDestination {\n  constructor(audioDestinationId) {\n    this.privPlaybackStarted = false;\n    this.privAppendingToBuffer = false;\n    this.privMediaSourceOpened = false;\n    this.privBytesReceived = 0;\n    this.privId = audioDestinationId ? audioDestinationId : Exports_js_1.createNoDashGuid();\n    this.privIsPaused = false;\n    this.privIsClosed = false;\n  }\n  id() {\n    return this.privId;\n  }\n  write(buffer, cb, err) {\n    if (this.privAudioBuffer !== undefined) {\n      this.privAudioBuffer.push(buffer);\n      this.updateSourceBuffer().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n    } else if (this.privAudioOutputStream !== undefined) {\n      this.privAudioOutputStream.write(buffer);\n      this.privBytesReceived += buffer.byteLength;\n    }\n  }\n  close(cb, err) {\n    this.privIsClosed = true;\n    if (this.privSourceBuffer !== undefined) {\n      this.handleSourceBufferUpdateEnd().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n    } else if (this.privAudioOutputStream !== undefined && typeof window !== \"undefined\") {\n      if ((this.privFormat.formatTag === AudioStreamFormat_js_1.AudioFormatTag.PCM || this.privFormat.formatTag === AudioStreamFormat_js_1.AudioFormatTag.MuLaw || this.privFormat.formatTag === AudioStreamFormat_js_1.AudioFormatTag.ALaw) && this.privFormat.hasHeader === false) {\n        // eslint-disable-next-line no-console\n        console.warn(\"Play back is not supported for raw PCM, mulaw or alaw format without header.\");\n        if (!!this.onAudioEnd) {\n          this.onAudioEnd(this);\n        }\n      } else {\n        let receivedAudio = new ArrayBuffer(this.privBytesReceived);\n        this.privAudioOutputStream.read(receivedAudio).then(() => {\n          receivedAudio = this.privFormat.addHeader(receivedAudio);\n          const audioBlob = new Blob([receivedAudio], {\n            type: AudioFormatToMimeType[this.privFormat.formatTag]\n          });\n          this.privAudio.src = window.URL.createObjectURL(audioBlob);\n          this.notifyPlayback().then(() => {\n            if (!!cb) {\n              cb();\n            }\n          }, error => {\n            if (!!err) {\n              err(error);\n            }\n          });\n        }, error => {\n          if (!!err) {\n            err(error);\n          }\n        });\n      }\n    } else {\n      // unsupported format, call onAudioEnd directly.\n      if (!!this.onAudioEnd) {\n        this.onAudioEnd(this);\n      }\n    }\n  }\n  set format(format) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (typeof AudioContext !== \"undefined\" || typeof window !== \"undefined\" && typeof window.webkitAudioContext !== \"undefined\") {\n      this.privFormat = format;\n      const mimeType = AudioFormatToMimeType[this.privFormat.formatTag];\n      if (mimeType === undefined) {\n        // eslint-disable-next-line no-console\n        console.warn(`Unknown mimeType for format ${AudioStreamFormat_js_1.AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`);\n      } else if (typeof MediaSource !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\n        this.privAudio = new Audio();\n        this.privAudioBuffer = [];\n        this.privMediaSource = new MediaSource();\n        this.privAudio.src = URL.createObjectURL(this.privMediaSource);\n        this.privAudio.load();\n        this.privMediaSource.onsourceopen = () => {\n          this.privMediaSourceOpened = true;\n          this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\n          this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType);\n          this.privSourceBuffer.onupdate = () => {\n            this.updateSourceBuffer().catch(reason => {\n              Exports_js_1.Events.instance.onEvent(new Exports_js_1.BackgroundEvent(reason));\n            });\n          };\n          this.privSourceBuffer.onupdateend = () => {\n            this.handleSourceBufferUpdateEnd().catch(reason => {\n              Exports_js_1.Events.instance.onEvent(new Exports_js_1.BackgroundEvent(reason));\n            });\n          };\n          this.privSourceBuffer.onupdatestart = () => {\n            this.privAppendingToBuffer = false;\n          };\n        };\n        this.updateSourceBuffer().catch(reason => {\n          Exports_js_1.Events.instance.onEvent(new Exports_js_1.BackgroundEvent(reason));\n        });\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn(`Format ${AudioStreamFormat_js_1.AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`);\n        this.privAudioOutputStream = new AudioOutputStream_js_1.PullAudioOutputStreamImpl();\n        this.privAudioOutputStream.format = this.privFormat;\n        this.privAudio = new Audio();\n      }\n    }\n  }\n  get volume() {\n    var _a, _b;\n    return (_b = (_a = this.privAudio) === null || _a === void 0 ? void 0 : _a.volume) !== null && _b !== void 0 ? _b : -1;\n  }\n  set volume(volume) {\n    if (!!this.privAudio) {\n      this.privAudio.volume = volume;\n    }\n  }\n  mute() {\n    if (!!this.privAudio) {\n      this.privAudio.muted = true;\n    }\n  }\n  unmute() {\n    if (!!this.privAudio) {\n      this.privAudio.muted = false;\n    }\n  }\n  get isClosed() {\n    return this.privIsClosed;\n  }\n  get currentTime() {\n    if (this.privAudio !== undefined) {\n      return this.privAudio.currentTime;\n    }\n    return -1;\n  }\n  pause() {\n    if (!this.privIsPaused && this.privAudio !== undefined) {\n      this.privAudio.pause();\n      this.privIsPaused = true;\n    }\n  }\n  resume(cb, err) {\n    if (this.privIsPaused && this.privAudio !== undefined) {\n      this.privAudio.play().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n      this.privIsPaused = false;\n    }\n  }\n  get internalAudio() {\n    return this.privAudio;\n  }\n  updateSourceBuffer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privAudioBuffer !== undefined && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {\n        this.privAppendingToBuffer = true;\n        const binary = this.privAudioBuffer.shift();\n        try {\n          this.privSourceBuffer.appendBuffer(binary);\n        } catch (error) {\n          this.privAudioBuffer.unshift(binary);\n          // eslint-disable-next-line no-console\n          console.log(\"buffer filled, pausing addition of binaries until space is made\");\n          return;\n        }\n        yield this.notifyPlayback();\n      } else if (this.canEndStream()) {\n        yield this.handleSourceBufferUpdateEnd();\n      }\n    });\n  }\n  handleSourceBufferUpdateEnd() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.canEndStream() && this.sourceBufferAvailable()) {\n        this.privMediaSource.endOfStream();\n        yield this.notifyPlayback();\n      }\n    });\n  }\n  notifyPlayback() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privPlaybackStarted && this.privAudio !== undefined) {\n        this.privPlaybackStarted = true;\n        if (!!this.onAudioStart) {\n          this.onAudioStart(this);\n        }\n        this.privAudio.onended = () => {\n          if (!!this.onAudioEnd) {\n            this.onAudioEnd(this);\n          }\n        };\n        if (!this.privIsPaused) {\n          yield this.privAudio.play();\n        }\n      }\n    });\n  }\n  canEndStream() {\n    return this.isClosed && this.privSourceBuffer !== undefined && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\";\n  }\n  sourceBufferAvailable() {\n    return this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating;\n  }\n}\nexports.SpeakerAudioDestination = SpeakerAudioDestination;\n\n//# sourceMappingURL=SpeakerAudioDestination.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}